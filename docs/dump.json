[
  {
    "__docId__": 0,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/babel-maybefill.js",
    "memberof": null,
    "longname": "src/babel-maybefill.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "if (!('regeneratorRuntime' in global)) {\n  require('babel-polyfill');\n}\n"
  },
  {
    "__docId__": 1,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/cli.js",
    "memberof": null,
    "longname": "src/cli.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "#!/usr/bin/env node\n\nimport './babel-maybefill';\nimport path from 'path';\nimport mkdirp from 'mkdirp';\nimport _ from 'lodash';\n\nimport {createCompilerHostFromProjectRoot} from './config-parser';\nimport {forAllFiles} from './for-all-files';\n\nprocess.on('unhandledRejection', (e) => {\n  d(e.message || e);\n  d(e.stack || '');\n});\n\nprocess.on('uncaughtException', (e) => {\n  d(e.message || e);\n  d(e.stack || '');\n});\n\nasync function main(appDir, sourceDirs) {\n  let compilerHost = null;\n  let rootCacheDir = path.join(appDir, '.cache');\n  mkdirp.sync(rootCacheDir);\n  \n  if (process.env.NODE_ENV !== 'production') {\n    console.log(`Using NODE_ENV = ${process.env.NODE_ENV || 'development'}`);\n  }\n  \n  d(`main: ${appDir}, ${JSON.stringify(sourceDirs)}`);\n  try {\n    compilerHost = await createCompilerHostFromProjectRoot(appDir, rootCacheDir);\n  } catch (e) {\n    console.error(`Couldn't set up compilers: ${e.message}`);\n    d(e.stack);\n\n    throw e;\n  }\n  \n  await Promise.all(_.map(sourceDirs, (dir) => forAllFiles(dir, async (f) => {\n    try {\n      d(`Starting compilation for ${f}`);\n      await compilerHost.compile(f);\n    } catch (e) {\n      console.error(`Failed to compile file: ${f}`);\n      console.error(e.message);\n\n      d(e.stack);\n    }\n  })));\n  \n  d('Saving out configuration');\n  await compilerHost.saveConfiguration();\n}\n\nconst d = require('debug')('electron-compile');\n\nconst yargs = require('yargs')\n  .usage('Usage: electron-compile --appdir [root-app-dir] paths...')\n  .alias('a', 'appdir')\n  .describe('a', 'The top-level application directory (i.e. where your package.json is)')\n  .help('h')\n  .alias('h', 'help')\n  .epilog('Copyright 2015');\n\nconst argv = yargs.argv;\n\nif (!argv._ || argv._.length < 1) {\n  yargs.showHelp();\n  process.exit(-1);\n}\n\nconst sourceDirs = argv._;\nconst appDir = argv.a || process.env.PWD;\n\nmain(appDir, sourceDirs)\n  .then(() => process.exit(0))\n  .catch((e) => {\n    console.error(e.message || e);\n    d(e.stack);\n    \n    console.error(\"Compilation failed!\\nFor extra information, set the DEBUG environment variable to '*'\");\n    process.exit(-1);\n  });  \n"
  },
  {
    "__docId__": 2,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "main",
    "memberof": "src/cli.js",
    "longname": "src/cli.js~main",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "appDir",
        "types": [
          "*"
        ]
      },
      {
        "name": "sourceDirs",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 3,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "d",
    "memberof": "src/cli.js",
    "longname": "src/cli.js~d",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 56,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "yargs",
    "memberof": "src/cli.js",
    "longname": "src/cli.js~yargs",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 58,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "argv",
    "memberof": "src/cli.js",
    "longname": "src/cli.js~argv",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "sourceDirs",
    "memberof": "src/cli.js",
    "longname": "src/cli.js~sourceDirs",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 73,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "appDir",
    "memberof": "src/cli.js",
    "longname": "src/cli.js~appDir",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/cli.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 74,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/compile-cache.js",
    "memberof": null,
    "longname": "src/compile-cache.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import fs from 'fs';\nimport path from 'path';\nimport zlib from 'zlib';\nimport createDigestForObject from './digest-for-object';\nimport {pfs, pzlib} from './promise';\nimport mkdirp from 'mkdirp';\n\nconst d = require('debug')('electron-compile:compile-cache');\n\n/**\n * CompileCache manages getting and setting entries for a single compiler; each\n * in-use compiler will have an instance of this class, usually created via\n * {@link createFromCompiler}. \n * \n * You usually will not use this class directly, it is an implementation class \n * for {@link CompileHost}.\n */ \nexport default class CompileCache {\n  /**  \n   * Creates an instance, usually used for testing only.\n   *    \n   * @param  {string} cachePath  The root directory to use as a cache path\n   *\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is \n   *                                             optionally pre-loaded.\n   */   \n  constructor(cachePath, fileChangeCache) {\n    this.cachePath = cachePath;\n    this.fileChangeCache = fileChangeCache;\n  }\n  \n  /**  \n   * Creates a CompileCache from a class compatible with the CompilerBase \n   * interface. This method uses the compiler name / version / options to \n   * generate a unique directory name for cached results\n   *    \n   * @param  {string} cachePath  The root path to use for the cache, a directory\n   *                             representing the hash of the compiler parameters\n   *                             will be created here.\n   *\n   * @param  {CompilerBase} compiler  The compiler to use for version / option\n   *                                  information.\n   *\n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is \n   *                                             optionally pre-loaded.\n   *\n   * @return {CompileCache}  A configured CompileCache instance.\n   */   \n  static createFromCompiler(cachePath, compiler, fileChangeCache) {\n    let newCachePath = null;\n    let getCachePath = () => {\n      if (newCachePath) return newCachePath;\n\n      const digestObj = {\n        name: compiler.name || Object.getPrototypeOf(compiler).constructor.name,\n        version: compiler.getCompilerVersion(),\n        options: compiler.compilerOptions\n      };\n\n      newCachePath = path.join(cachePath, createDigestForObject(digestObj));\n\n      d(`Path for ${digestObj.name}: ${newCachePath}`);\n      d(`Set up with parameters: ${JSON.stringify(digestObj)}`);\n      mkdirp.sync(newCachePath);\n      return newCachePath;\n    };\n    \n    let ret = new CompileCache('', fileChangeCache);\n    ret.getCachePath = getCachePath;\n    \n    return ret;\n  }\n  \n  /**  \n   * Returns a file's compiled contents from the cache.\n   *    \n   * @param  {string} filePath  The path to the file. FileChangedCache will look\n   *                            up the hash and use that as the key in the cache.\n   *\n   * @return {Promise<Object>}  An object with all kinds of information\n   *\n   * @property {Object} hashInfo  The hash information returned from getHashForPath\n   * @property {string} code  The source code if the file was a text file\n   * @property {Buffer} binaryData  The file if it was a binary file\n   * @property {string} mimeType  The MIME type saved in the cache.\n   * @property {string[]} dependentFiles  The dependent files returned from \n   *                                      compiling the file, if any.\n   */   \n  async get(filePath) {\n    d(`Fetching ${filePath} from cache`);\n    let hashInfo = await this.fileChangeCache.getHashForPath(path.resolve(filePath));\n  \n    let code = null;\n    let mimeType = null;\n    let binaryData = null;\n    let dependentFiles = null;\n    \n    let cacheFile = null;\n    try {\n      cacheFile = path.join(this.getCachePath(), hashInfo.hash);\n      let result = null;\n\n      if (hashInfo.isFileBinary) {\n        d(\"File is binary, reading out info\");\n        let info = JSON.parse(await pfs.readFile(cacheFile + '.info'));\n        mimeType = info.mimeType;\n        dependentFiles = info.dependentFiles;\n        \n        binaryData = hashInfo.binaryData;\n        if (!binaryData) {\n          binaryData = await pfs.readFile(cacheFile);\n          binaryData = await pzlib.gunzip(binaryData);\n        }\n      } else {\n        let buf = await pfs.readFile(cacheFile);\n        let str = (await pzlib.gunzip(buf)).toString('utf8');\n\n        result = JSON.parse(str);\n        code = result.code;\n        mimeType = result.mimeType;\n        dependentFiles = result.dependentFiles;\n      }\n    } catch (e) {\n      d(`Failed to read cache for ${filePath}, looked in ${cacheFile}: ${e.message}`);\n    }\n    \n    return { hashInfo, code, mimeType, binaryData, dependentFiles };\n  }\n\n  \n  /**  \n   * Saves a compiled result to cache\n   *    \n   * @param  {Object} hashInfo  The hash information returned from getHashForPath   \n   *\n   * @param  {string / Buffer} codeOrBinaryData   The file's contents, either as\n   *                                              a string or a Buffer.\n   * @param  {string} mimeType  The MIME type returned by the compiler.\n   *\n   * @param  {string[]} dependentFiles  The list of dependent files returned by\n   *                                    the compiler.\n   * @return {Promise}  Completion.\n   */   \n  async save(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {\n    let buf = null;\n    let target = path.join(this.getCachePath(), hashInfo.hash);\n    d(`Saving to ${target}`);\n    \n    if (hashInfo.isFileBinary) {\n      buf = await pzlib.gzip(codeOrBinaryData);\n      await pfs.writeFile(target + '.info', JSON.stringify({mimeType, dependentFiles}), 'utf8');\n    } else {\n      buf = await pzlib.gzip(new Buffer(JSON.stringify({code: codeOrBinaryData, mimeType, dependentFiles})));\n    }\n    \n    await pfs.writeFile(target, buf);\n  }\n  \n  /**  \n   * Attempts to first get a key via {@link get}, then if it fails, call a method\n   * to retrieve the contents, then save the result to cache.\n   * \n   * The fetcher parameter is expected to have the signature:\n   * \n   * Promise<Object> fetcher(filePath : string, hashInfo : Object);\n   * \n   * hashInfo is a value returned from getHashForPath\n   * The return value of fetcher must be an Object with the properties:\n   * \n   * mimeType - the MIME type of the data to save\n   * code (optional) - the source code as a string, if file is text\n   * binaryData (optional) - the file contents as a Buffer, if file is binary\n   * dependentFiles - the dependent files returned by the compiler.\n   *\n   * @param  {string} filePath  The path to the file. FileChangedCache will look\n   *                            up the hash and use that as the key in the cache.\n   *\n   * @param  {Function} fetcher  A method which conforms to the description above.\n   *\n   * @return {Promise<Object>}  An Object which has the same fields as the \n   *                            {@link get} method return result.\n   */   \n  async getOrFetch(filePath, fetcher) {\n    let cacheResult = await this.get(filePath);\n    if (cacheResult.code || cacheResult.binaryData) return cacheResult;\n    \n    let result = await fetcher(filePath, cacheResult.hashInfo) || { hashInfo: cacheResult.hashInfo };\n    \n    if (result.mimeType && !cacheResult.hashInfo.isInNodeModules) {\n      d(`Cache miss: saving out info for ${filePath}`);\n      await this.save(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);\n    }\n    \n    result.hashInfo = cacheResult.hashInfo;\n    return result;\n  }\n  \n  getSync(filePath) {\n    d(`Fetching ${filePath} from cache`);\n    let hashInfo = this.fileChangeCache.getHashForPathSync(path.resolve(filePath));\n  \n    let code = null;\n    let mimeType = null;\n    let binaryData = null;\n    let dependentFiles = null;\n    \n    try {\n      let cacheFile = path.join(this.getCachePath(), hashInfo.hash);\n      \n      let result = null;\n      if (hashInfo.isFileBinary) {\n        d(\"File is binary, reading out info\");\n        let info = JSON.parse(fs.readFileSync(cacheFile + '.info'));\n        mimeType = info.mimeType;\n        dependentFiles = info.dependentFiles;\n        \n        binaryData = hashInfo.binaryData;\n        if (!binaryData) {\n          binaryData = fs.readFileSync(cacheFile);\n          binaryData = zlib.gunzipSync(binaryData);\n        }\n      } else {\n        let buf = fs.readFileSync(cacheFile);\n        let str = (zlib.gunzipSync(buf)).toString('utf8');\n\n        result = JSON.parse(str);\n        code = result.code;\n        mimeType = result.mimeType;\n        dependentFiles = result.dependentFiles;\n      }\n    } catch (e) {\n      d(`Failed to read cache for ${filePath}`);\n    }\n    \n    return { hashInfo, code, mimeType, binaryData, dependentFiles };\n  }\n\n  saveSync(hashInfo, codeOrBinaryData, mimeType, dependentFiles) {\n    let buf = null;\n    let target = path.join(this.getCachePath(), hashInfo.hash);\n    d(`Saving to ${target}`);\n    \n    if (hashInfo.isFileBinary) {\n      buf = zlib.gzipSync(codeOrBinaryData);\n      fs.writeFileSync(target + '.info', JSON.stringify({mimeType, dependentFiles}), 'utf8');\n    } else {\n      buf = zlib.gzipSync(new Buffer(JSON.stringify({code: codeOrBinaryData, mimeType, dependentFiles})));\n    }\n    \n    fs.writeFileSync(target, buf);\n  }\n  \n  getOrFetchSync(filePath, fetcher) {\n    let cacheResult = this.getSync(filePath);\n    if (cacheResult.code || cacheResult.binaryData) return cacheResult;\n    \n    let result = fetcher(filePath, cacheResult.hashInfo) || { hashInfo: cacheResult.hashInfo };\n    \n    if (result.mimeType && !cacheResult.hashInfo.isInNodeModules) {\n      d(`Cache miss: saving out info for ${filePath}`);\n      this.saveSync(cacheResult.hashInfo, result.code || result.binaryData, result.mimeType, result.dependentFiles);\n    }\n    \n    result.hashInfo = cacheResult.hashInfo;\n    return result;\n  }\n  \n  \n  /**  \n   * @private\n   */   \n  getCachePath() {\n    // NB: This is an evil hack so that createFromCompiler can stomp it\n    // at will\n    return this.cachePath;\n  }\n    \n    \n  /**    \n   * Returns whether a file should not be compiled. Note that this doesn't \n   * necessarily mean it won't end up in the cache, only that its contents are\n   * saved verbatim instead of trying to find an appropriate compiler.\n   *    \n   * @param  {Object} hashInfo  The hash information returned from getHashForPath   \n   *\n   * @return {boolean}  True if a file should be ignored\n   */   \n  static shouldPassthrough(hashInfo) {\n    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;\n  }\n}\n"
  },
  {
    "__docId__": 9,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "d",
    "memberof": "src/compile-cache.js",
    "longname": "src/compile-cache.js~d",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/compile-cache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 10,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "CompileCache",
    "memberof": "src/compile-cache.js",
    "longname": "src/compile-cache.js~CompileCache",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/compile-cache.js",
    "importStyle": "CompileCache",
    "description": "CompileCache manages getting and setting entries for a single compiler; each\nin-use compiler will have an instance of this class, usually created via\n{@link createFromCompiler}. \n\nYou usually will not use this class directly, it is an implementation class \nfor {@link CompileHost}.",
    "lineNumber": 18,
    "interface": false
  },
  {
    "__docId__": 11,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#constructor",
    "access": null,
    "description": " \nCreates an instance, usually used for testing only.\n   ",
    "lineNumber": 27,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "cachePath",
        "description": "The root directory to use as a cache path"
      },
      {
        "nullable": null,
        "types": [
          "FileChangedCache"
        ],
        "spread": false,
        "optional": false,
        "name": "fileChangeCache",
        "description": "A file-change cache that is \n                                            optionally pre-loaded."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 12,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "cachePath",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#cachePath",
    "access": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 13,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "fileChangeCache",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#fileChangeCache",
    "access": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "createFromCompiler",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache.createFromCompiler",
    "access": null,
    "description": " \nCreates a CompileCache from a class compatible with the CompilerBase \ninterface. This method uses the compiler name / version / options to \ngenerate a unique directory name for cached results\n   ",
    "lineNumber": 49,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "cachePath",
        "description": "The root path to use for the cache, a directory\n                            representing the hash of the compiler parameters\n                            will be created here."
      },
      {
        "nullable": null,
        "types": [
          "CompilerBase"
        ],
        "spread": false,
        "optional": false,
        "name": "compiler",
        "description": "The compiler to use for version / option\n                                 information."
      },
      {
        "nullable": null,
        "types": [
          "FileChangedCache"
        ],
        "spread": false,
        "optional": false,
        "name": "fileChangeCache",
        "description": "A file-change cache that is \n                                            optionally pre-loaded."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CompileCache"
      ],
      "spread": false,
      "description": "A configured CompileCache instance."
    },
    "generator": false
  },
  {
    "__docId__": 15,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "get",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#get",
    "access": null,
    "description": " \nReturns a file's compiled contents from the cache.\n   ",
    "lineNumber": 89,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to the file. FileChangedCache will look\n                           up the hash and use that as the key in the cache."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "hashInfo",
        "description": "The hash information returned from getHashForPath"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "code",
        "description": "The source code if the file was a text file"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "binaryData",
        "description": "The file if it was a binary file"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mimeType",
        "description": "The MIME type saved in the cache."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "dependentFiles",
        "description": "The dependent files returned from \n                                     compiling the file, if any."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "An object with all kinds of information"
    },
    "generator": false
  },
  {
    "__docId__": 16,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "save",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#save",
    "access": null,
    "description": " \nSaves a compiled result to cache\n   ",
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "hashInfo",
        "description": "The hash information returned from getHashForPath"
      },
      {
        "nullable": null,
        "types": [
          "string / Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "codeOrBinaryData",
        "description": "The file's contents, either as\n                                             a string or a Buffer."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mimeType",
        "description": "The MIME type returned by the compiler."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "dependentFiles",
        "description": "The list of dependent files returned by\n                                   the compiler."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion."
    },
    "generator": false
  },
  {
    "__docId__": 17,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getOrFetch",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#getOrFetch",
    "access": null,
    "description": " \nAttempts to first get a key via {@link get}, then if it fails, call a method\nto retrieve the contents, then save the result to cache.\n\nThe fetcher parameter is expected to have the signature:\n\nObject fetcher(filePath : string, hashInfo : Object);\n\nhashInfo is a value returned from getHashForPath\nThe return value of fetcher must be an Object with the properties:\n\nmimeType - the MIME type of the data to save\ncode (optional) - the source code as a string, if file is text\nbinaryData (optional) - the file contents as a Buffer, if file is binary\ndependentFiles - the dependent files returned by the compiler.",
    "lineNumber": 183,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to the file. FileChangedCache will look\n                           up the hash and use that as the key in the cache."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fetcher",
        "description": "A method which conforms to the description above."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "An Object which has the same fields as the \n                           {@link get} method return result."
    },
    "generator": false
  },
  {
    "__docId__": 18,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSync",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#getSync",
    "access": null,
    "description": " \nReturns a file's compiled contents from the cache.\n   ",
    "lineNumber": 198,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to the file. FileChangedCache will look\n                           up the hash and use that as the key in the cache."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "hashInfo",
        "description": "The hash information returned from getHashForPath"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "code",
        "description": "The source code if the file was a text file"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "binaryData",
        "description": "The file if it was a binary file"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mimeType",
        "description": "The MIME type saved in the cache."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "dependentFiles",
        "description": "The dependent files returned from \n                                     compiling the file, if any."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "An object with all kinds of information"
    },
    "generator": false
  },
  {
    "__docId__": 19,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "saveSync",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#saveSync",
    "access": null,
    "description": " \nSaves a compiled result to cache\n   ",
    "lineNumber": 238,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "hashInfo",
        "description": "The hash information returned from getHashForPath"
      },
      {
        "nullable": null,
        "types": [
          "string / Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "codeOrBinaryData",
        "description": "The file's contents, either as\n                                             a string or a Buffer."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mimeType",
        "description": "The MIME type returned by the compiler."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "dependentFiles",
        "description": "The list of dependent files returned by\n                                   the compiler."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion."
    },
    "generator": false
  },
  {
    "__docId__": 20,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getOrFetchSync",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#getOrFetchSync",
    "access": null,
    "description": " \nAttempts to first get a key via {@link get}, then if it fails, call a method\nto retrieve the contents, then save the result to cache.\n\nThe fetcher parameter is expected to have the signature:\n\nObject fetcher(filePath : string, hashInfo : Object);\n\nhashInfo is a value returned from getHashForPath\nThe return value of fetcher must be an Object with the properties:\n\nmimeType - the MIME type of the data to save\ncode (optional) - the source code as a string, if file is text\nbinaryData (optional) - the file contents as a Buffer, if file is binary\ndependentFiles - the dependent files returned by the compiler.",
    "lineNumber": 253,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to the file. FileChangedCache will look\n                           up the hash and use that as the key in the cache."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "fetcher",
        "description": "A method which conforms to the description above."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "An Object which has the same fields as the \n                           {@link get} method return result."
    },
    "generator": false
  },
  {
    "__docId__": 21,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getCachePath",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache#getCachePath",
    "access": "private",
    "description": " ",
    "lineNumber": 272,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 22,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "shouldPassthrough",
    "memberof": "src/compile-cache.js~CompileCache",
    "longname": "src/compile-cache.js~CompileCache.shouldPassthrough",
    "access": null,
    "description": "   \nReturns whether a file should not be compiled. Note that this doesn't \nnecessarily mean it won't end up in the cache, only that its contents are\nsaved verbatim instead of trying to find an appropriate compiler.\n   ",
    "lineNumber": 288,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "hashInfo",
        "description": "The hash information returned from getHashForPath"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": "True if a file should be ignored"
    },
    "generator": false
  },
  {
    "__docId__": 23,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/compiler-host.js",
    "memberof": null,
    "longname": "src/compiler-host.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\nimport mimeTypes from 'mime-types';\nimport fs from 'fs';\nimport zlib from 'zlib';\nimport path from 'path';\nimport {pfs, pzlib} from './promise';\n\nimport {forAllFiles, forAllFilesSync} from './for-all-files';\nimport CompileCache from './compile-cache';\nimport FileChangedCache from './file-change-cache';\nimport ReadOnlyCompiler from './read-only-compiler';\n\nconst d = require('debug')('electron-compile:compiler-host');\n\n// This isn't even my\nconst finalForms = {\n  'text/javascript': true,\n  'application/javascript': true,\n  'text/html': true,\n  'text/css': true,\n  'image/svg+xml': true\n};\n\n/**\n * This class is the top-level class that encapsulates all of the logic of \n * compiling and caching application code. If you're looking for a \"Main class\",\n * this is it.\n * \n * This class can be created directly but it is usually created via the methods\n * in config-parser, which will among other things, set up the compiler options\n * given a project root.\n * \n * CompilerHost is also the top-level class that knows how to serialize all of the\n * information necessary to recreate itself, either as a development host (i.e.\n * will allow cache misses and actual compilation), or as a read-only version of\n * itself for production.\n */ \nexport default class CompilerHost {\n  /**  \n   * Creates an instance of CompilerHost. You probably want to use the methods\n   * in config-parser for development, or {@link createReadonlyFromConfiguration}\n   * for production instead.\n   *    \n   * @param  {string} rootCacheDir  The root directory to use for the cache\n   * \n   * @param  {Object} compilers  an Object whose keys are input MIME types and\n   *                             whose values are instances of CompilerBase. Create\n   *                             this via the {@link createCompilers} method in\n   *                             config-parser.\n   * \n   * @param  {FileChangedCache} fileChangeCache  A file-change cache that is \n   *                                             optionally pre-loaded.\n   * \n   * @param  {boolean} readOnlyMode  If True, cache misses will fail and \n   *                                 compilation will not be attempted.\n   * \n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\n   *                                         which doesn't have a matching compiler,\n   *                                         this compiler will be used instead. If\n   *                                         null, will fail compilation. A good\n   *                                         alternate fallback is the compiler for\n   *                                         'text/plain', which is guaranteed to be\n   *                                         present.\n   */   \n  constructor(rootCacheDir, compilers, fileChangeCache, readOnlyMode, fallbackCompiler = null) {\n    let compilersByMimeType = _.assign({}, compilers);\n    _.assign(this, {rootCacheDir, compilersByMimeType, fileChangeCache, readOnlyMode, fallbackCompiler});\n    this.appRoot = this.fileChangeCache.appRoot;\n    \n    this.cachesForCompilers = _.reduce(Object.keys(compilersByMimeType), (acc, x) => {\n      let compiler = compilersByMimeType[x];\n      if (acc.has(compiler)) return acc;\n\n      acc.set(compiler, CompileCache.createFromCompiler(rootCacheDir, compiler, fileChangeCache));\n      return acc;\n    }, new Map());\n  }\n    \n  /**    \n   * Creates a production-mode CompilerHost from the previously saved \n   * configuration\n   *    \n   * @param  {string} rootCacheDir  The root directory to use for the cache. This\n   *                                cache must have cache information saved via\n   *                                {@link saveConfiguration}\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\n   *                                         which doesn't have a matching compiler,\n   *                                         this compiler will be used instead. If\n   *                                         null, will fail compilation. A good\n   *                                         alternate fallback is the compiler for\n   *                                         'text/plain', which is guaranteed to be\n   *                                         present. \n   *\n   * @return {Promise<CompilerHost>}  A read-only CompilerHost\n   */   \n  static async createReadonlyFromConfiguration(rootCacheDir, appRoot, fallbackCompiler=null) {\n    let target = path.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = await pfs.readFile(target);\n    let info = JSON.parse(await pzlib.gunzip(buf));\n    \n    let fileChangeCache = FileChangedCache.loadFromData(info.fileChangeCache, appRoot, true);\n\n    let compilers = _.reduce(Object.keys(info.compilers), (acc, x) => {\n      let cur = info.compilers[x];\n      acc[x] = new ReadOnlyCompiler(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);\n      \n      return acc;\n    }, {});\n    \n    return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);\n  }\n\n  /**    \n   * Creates a development-mode CompilerHost from the previously saved \n   * configuration.\n   *    \n   * @param  {string} rootCacheDir  The root directory to use for the cache. This\n   *                                cache must have cache information saved via\n   *                                {@link saveConfiguration}\n   *\n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   *\n   * @param  {Object} compilersByMimeType  an Object whose keys are input MIME \n   *                                       types and whose values are instances \n   *                                       of CompilerBase. Create this via the \n   *                                       {@link createCompilers} method in \n   *                                       config-parser.\n   * \n   * @param  {CompilerBase} fallbackCompiler (optional)  When a file is compiled\n   *                                         which doesn't have a matching compiler,\n   *                                         this compiler will be used instead. If\n   *                                         null, will fail compilation. A good\n   *                                         alternate fallback is the compiler for\n   *                                         'text/plain', which is guaranteed to be\n   *                                         present. \n   *\n   * @return {Promise<CompilerHost>}  A read-only CompilerHost\n   */   \n  static async createFromConfiguration(rootCacheDir, appRoot, compilersByMimeType, fallbackCompiler=null) {\n    let target = path.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = await pfs.readFile(target);\n    let info = JSON.parse(await pzlib.gunzip(buf));\n    \n    let fileChangeCache = FileChangedCache.loadFromData(info.fileChangeCache, appRoot, false);\n    \n    _.each(Object.keys(info.compilers), (x) => {\n      let cur = info.compilers[x];\n      compilersByMimeType[x].compilerOptions = cur.compilerOptions;\n    });\n    \n    return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);\n  }\n  \n  \n  /**  \n   * Saves the current compiler configuration to a file that \n   * {@link createReadonlyFromConfiguration} can use to recreate the current \n   * compiler environment\n   *    \n   * @return {Promise}  Completion\n   */   \n  async saveConfiguration() {\n    let serializedCompilerOpts = _.reduce(Object.keys(this.compilersByMimeType), (acc, x) => {\n      let compiler = this.compilersByMimeType[x];\n      let Klass = Object.getPrototypeOf(compiler).constructor;\n      \n      let val = {\n        name: Klass.name,\n        inputMimeTypes: Klass.getInputMimeTypes(),\n        compilerOptions: compiler.compilerOptions,\n        compilerVersion: compiler.getCompilerVersion()\n      };\n      \n      acc[x] = val;\n      return acc;\n    }, {});\n    \n    let info = {\n      fileChangeCache: this.fileChangeCache.getSavedData(),\n      compilers: serializedCompilerOpts\n    };\n    \n    let target = path.join(this.rootCacheDir, 'compiler-info.json.gz');\n    let buf = await pzlib.gzip(new Buffer(JSON.stringify(info)));\n    await pfs.writeFile(target, buf);\n  }\n  \n  /**  \n   * Compiles a file and returns the compiled result.\n   *    \n   * @param  {string} filePath  The path to the file to compile\n   *\n   * @return {Promise<object>}  An Object with the compiled result\n   *\n   * @property {Object} hashInfo  The hash information returned from getHashForPath\n   * @property {string} code  The source code if the file was a text file\n   * @property {Buffer} binaryData  The file if it was a binary file\n   * @property {string} mimeType  The MIME type saved in the cache.\n   * @property {string[]} dependentFiles  The dependent files returned from \n   *                                      compiling the file, if any.\n   */   \n  compile(filePath) {\n    return (this.readOnlyMode ? this.compileReadOnly(filePath) : this.fullCompile(filePath));\n  }\n  \n  \n  /**  \n   * Handles compilation in read-only mode\n   *\n   * @private\n   */   \n  async compileReadOnly(filePath) {\n    // We guarantee that node_modules are always shipped directly\n    let type = mimeTypes.lookup(filePath);\n    if (FileChangedCache.isInNodeModules(filePath)) {\n      return { \n        mimeType: type || 'application/javascript',\n        code: await pfs.readFile(filePath, 'utf8') \n      };    \n    }\n    \n    let hashInfo = await this.fileChangeCache.getHashForPath(filePath);\n\n    // NB: Here, we're basically only using the compiler here to find\n    // the appropriate CompileCache\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ?\n      this.getPassthroughCompiler() :\n      this.compilersByMimeType[type || '__lolnothere'];\n\n    if (!compiler) compiler = this.fallbackCompiler;\n\n    let cache = this.cachesForCompilers.get(compiler);\n    let {code, binaryData, mimeType} = await cache.get(filePath);\n\n    code = code || binaryData;\n    if (!code || !mimeType) {\n      throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);\n    }\n\n    return { code, mimeType };\n  }\n\n  /**  \n   * Handles compilation in read-write mode\n   *\n   * @private\n   */     \n  async fullCompile(filePath) {\n    d(`Compiling ${filePath}`);\n    \n    let hashInfo = await this.fileChangeCache.getHashForPath(filePath);\n    let type = mimeTypes.lookup(filePath);\n    \n    if (hashInfo.isInNodeModules) {\n      let code = hashInfo.sourceCode || await pfs.readFile(filePath, 'utf8');\n      return { code, mimeType: type };\n    }\n\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ?\n      this.getPassthroughCompiler() :\n      this.compilersByMimeType[type || '__lolnothere'];\n\n    if (!compiler) {\n      d(`Falling back to passthrough compiler for ${filePath}`);\n      compiler = this.fallbackCompiler;\n    }\n\n    if (!compiler) {\n      throw new Error(`Couldn't find a compiler for ${filePath}`);\n    }\n\n    let cache = this.cachesForCompilers.get(compiler);\n    return await cache.getOrFetch(\n      filePath,\n      (filePath, hashInfo) => this.compileUncached(filePath, hashInfo, compiler));\n  }\n\n  /**  \n   * Handles invoking compilers independent of caching\n   *\n   * @private\n   */\n  async compileUncached(filePath, hashInfo, compiler) {\n    let inputMimeType = mimeTypes.lookup(filePath);\n    \n    if (hashInfo.isFileBinary) {\n      return {\n        binaryData: hashInfo.binaryData || await pfs.readFile(filePath),\n        mimeType: inputMimeType,\n        dependentFiles: []\n      };\n    }\n    \n    let ctx = {};\n    let code = hashInfo.sourceCode || await pfs.readFile(filePath, 'utf8');\n\n    if (!(await compiler.shouldCompileFile(code, ctx))) {\n      d(`Compiler returned false for shouldCompileFile: ${filePath}`);\n      return { code, mimeType: mimeTypes.lookup(filePath), dependentFiles: [] };\n    }\n\n    let dependentFiles = await compiler.determineDependentFiles(code, filePath, ctx);\n\n    d(`Using compiler options: ${JSON.stringify(compiler.compilerOptions)}`);\n    let result = await compiler.compile(code, filePath, ctx);\n\n    let shouldInlineHtmlify = \n      inputMimeType !== 'text/html' &&\n      result.mimeType === 'text/html';\n    \n    let isPassthrough = \n      result.mimeType === 'text/plain' || \n      !result.mimeType || \n      CompilerHost.shouldPassthrough(hashInfo);\n      \n    if ((finalForms[result.mimeType] && !shouldInlineHtmlify) || isPassthrough) {\n      // Got something we can use in-browser, let's return it\n      return _.assign(result, {dependentFiles});\n    } else {\n      d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);\n\n      hashInfo = _.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);\n      compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];\n\n      if (!compiler) {\n        d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);\n\n        throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);\n      }\n\n      return await this.compileUncached(\n        `${filePath}.${mimeTypes.extension(result.mimeType || 'txt')}`, \n        hashInfo, compiler);\n    }\n  }\n  \n  /**  \n   * Pre-caches an entire directory of files recursively. Usually used for \n   * building custom compiler tooling.\n   *    \n   * @param  {string} rootDirectory  The top-level directory to compile\n   *\n   * @param  {Function} shouldCompile (optional)  A Function which allows the \n   *                                  caller to disable compiling certain files.\n   *                                  It takes a fully-qualified path to a file,\n   *                                  and should return a Boolean.\n   *\n   * @return {Promise}  Completion.\n   */   \n  async compileAll(rootDirectory, shouldCompile=null) {\n    let should = shouldCompile || function() {return true;};\n\n    await forAllFiles(rootDirectory, (f) => {\n      if (!should(f)) return;\n\n      d(`Compiling ${f}`);\n      return this.compile(f, this.compilersByMimeType);\n    });\n  }\n  \n  /*\n   * Sync Methods\n   */\n   \n  compileSync(filePath) {\n    return (this.readOnlyMode ? this.compileReadOnlySync(filePath) : this.fullCompileSync(filePath));\n  }\n  \n  static createReadonlyFromConfigurationSync(rootCacheDir, appRoot, fallbackCompiler=null) {\n    let target = path.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = fs.readFileSync(target);\n    let info = JSON.parse(zlib.gunzipSync(buf));\n    \n    let fileChangeCache = FileChangedCache.loadFromData(info.fileChangeCache, appRoot, true);\n    \n    let compilers = _.reduce(Object.keys(info.compilers), (acc, x) => {\n      let cur = info.compilers[x];\n      acc[x] = new ReadOnlyCompiler(cur.name, cur.compilerVersion, cur.compilerOptions, cur.inputMimeTypes);\n      \n      return acc;\n    }, {});\n    \n    return new CompilerHost(rootCacheDir, compilers, fileChangeCache, true, fallbackCompiler);\n  }\n  \n  static createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType, fallbackCompiler=null) {\n    let target = path.join(rootCacheDir, 'compiler-info.json.gz');\n    let buf = fs.readFileSync(target);\n    let info = JSON.parse(zlib.gunzipSync(buf));\n    \n    let fileChangeCache = FileChangedCache.loadFromData(info.fileChangeCache, appRoot, false);\n    \n    _.each(Object.keys(info.compilers), (x) => {\n      let cur = info.compilers[x];\n      compilersByMimeType[x].compilerOptions = cur.compilerOptions;\n    });\n    \n    return new CompilerHost(rootCacheDir, compilersByMimeType, fileChangeCache, false, fallbackCompiler);\n  }\n   \n  saveConfigurationSync() {\n    let serializedCompilerOpts = _.reduce(Object.keys(this.compilersByMimeType), (acc, x) => {\n      let compiler = this.compilersByMimeType[x];\n      let Klass = Object.getPrototypeOf(compiler).constructor;\n      \n      let val = {\n        name: Klass.name,\n        inputMimeTypes: Klass.getInputMimeTypes(),\n        compilerOptions: compiler.compilerOptions,\n        compilerVersion: compiler.getCompilerVersion()\n      };\n      \n      acc[x] = val;\n      return acc;\n    }, {});\n    \n    let info = {\n      fileChangeCache: this.fileChangeCache.getSavedData(),\n      compilers: serializedCompilerOpts\n    };\n    \n    let target = path.join(this.rootCacheDir, 'compiler-info.json.gz');\n    let buf = zlib.gzipSync(new Buffer(JSON.stringify(info)));\n    fs.writeFileSync(target, buf);\n  }\n  \n  compileReadOnlySync(filePath) {\n    // We guarantee that node_modules are always shipped directly\n    let type = mimeTypes.lookup(filePath);\n    if (FileChangedCache.isInNodeModules(filePath)) {\n      return { \n        mimeType: type || 'application/javascript',\n        code: fs.readFileSync(filePath, 'utf8') \n      };    \n    }  \n\n    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);\n    \n    // We guarantee that node_modules are always shipped directly\n    if (hashInfo.isInNodeModules) {\n      return { \n        mimeType: type, \n        code: hashInfo.sourceCode || fs.readFileSync(filePath, 'utf8') \n      };    \n    }\n\n    // NB: Here, we're basically only using the compiler here to find\n    // the appropriate CompileCache\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ?\n      this.getPassthroughCompiler() :\n      this.compilersByMimeType[type || '__lolnothere'];\n\n    if (!compiler) compiler = this.fallbackCompiler;\n\n    let cache = this.cachesForCompilers.get(compiler);\n    let {code, binaryData, mimeType} = cache.getSync(filePath);\n\n    code = code || binaryData;\n    if (!code || !mimeType) {\n      throw new Error(`Asked to compile ${filePath} in production, is this file not precompiled?`);\n    }\n\n    return { code, mimeType };\n  }\n\n  fullCompileSync(filePath) {\n    d(`Compiling ${filePath}`);\n\n    let hashInfo = this.fileChangeCache.getHashForPathSync(filePath);\n    let type = mimeTypes.lookup(filePath);\n    \n    if (hashInfo.isInNodeModules) {\n      let code = hashInfo.sourceCode || fs.readFileSync(filePath, 'utf8');\n      return { code, mimeType: type };\n    }\n\n    let compiler = CompilerHost.shouldPassthrough(hashInfo) ?\n      this.getPassthroughCompiler() :\n      this.compilersByMimeType[type || '__lolnothere'];\n\n    if (!compiler) {\n      d(`Falling back to passthrough compiler for ${filePath}`);\n      compiler = this.fallbackCompiler;\n    }\n\n    if (!compiler) {\n      throw new Error(`Couldn't find a compiler for ${filePath}`);\n    }\n\n    let cache = this.cachesForCompilers.get(compiler);\n    return cache.getOrFetchSync(\n      filePath,\n      (filePath, hashInfo) => this.compileUncachedSync(filePath, hashInfo, compiler));\n  }\n\n  compileUncachedSync(filePath, hashInfo, compiler) {\n    let inputMimeType = mimeTypes.lookup(filePath);\n    \n    if (hashInfo.isFileBinary) {\n      return {\n        binaryData: hashInfo.binaryData || fs.readFileSync(filePath),\n        mimeType: inputMimeType,\n        dependentFiles: []\n      };\n    }\n  \n    let ctx = {};\n    let code = hashInfo.sourceCode || fs.readFileSync(filePath, 'utf8');\n\n    if (!(compiler.shouldCompileFileSync(code, ctx))) {\n      d(`Compiler returned false for shouldCompileFile: ${filePath}`);\n      return { code, mimeType: mimeTypes.lookup(filePath), dependentFiles: [] };\n    }\n\n    let dependentFiles = compiler.determineDependentFilesSync(code, filePath, ctx);\n\n    let result = compiler.compileSync(code, filePath, ctx);\n\n    let shouldInlineHtmlify = \n      inputMimeType !== 'text/html' &&\n      result.mimeType === 'text/html';\n      \n    let isPassthrough = \n      result.mimeType === 'text/plain' || \n      !result.mimeType || \n      CompilerHost.shouldPassthrough(hashInfo);\n      \n    if ((finalForms[result.mimeType] && !shouldInlineHtmlify) || isPassthrough) {\n      // Got something we can use in-browser, let's return it\n      return _.assign(result, {dependentFiles});\n    } else {\n      d(`Recursively compiling result of ${filePath} with non-final MIME type ${result.mimeType}, input was ${inputMimeType}`);\n\n      hashInfo = _.assign({ sourceCode: result.code, mimeType: result.mimeType }, hashInfo);\n      compiler = this.compilersByMimeType[result.mimeType || '__lolnothere'];\n\n      if (!compiler) {\n        d(`Recursive compile failed - intermediate result: ${JSON.stringify(result)}`);\n\n        throw new Error(`Compiling ${filePath} resulted in a MIME type of ${result.mimeType}, which we don't know how to handle`);\n      }\n\n      return this.compileUncachedSync(\n        `${filePath}.${mimeTypes.extension(result.mimeType || 'txt')}`, \n        hashInfo, compiler);\n    }\n  }\n\n  compileAllSync(rootDirectory, shouldCompile=null) {\n    let should = shouldCompile || function() {return true;};\n\n    forAllFilesSync(rootDirectory, (f) => {\n      if (!should(f)) return;\n      return this.compileSync(f, this.compilersByMimeType);\n    });\n  }\n  \n  /*\n   * Other stuff\n   */\n\n\n  /**\n   * Returns the passthrough compiler \n   *\n   * @private\n   */   \n  getPassthroughCompiler() {\n    return this.compilersByMimeType['text/plain'];\n  }\n\n\n  /**\n   * Determines whether we should even try to compile the content. Note that in\n   * some cases, content will still be in cache even if this returns true, and\n   * in other cases (isInNodeModules), we'll know explicitly to not even bother\n   * looking in the cache.\n   *    \n   * @private\n   */   \n  static shouldPassthrough(hashInfo) {\n    return hashInfo.isMinified || hashInfo.isInNodeModules || hashInfo.hasSourceMap || hashInfo.isFileBinary;\n  }\n}\n"
  },
  {
    "__docId__": 24,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "d",
    "memberof": "src/compiler-host.js",
    "longname": "src/compiler-host.js~d",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/compiler-host.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 25,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "finalForms",
    "memberof": "src/compiler-host.js",
    "longname": "src/compiler-host.js~finalForms",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/compiler-host.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "CompilerHost",
    "memberof": "src/compiler-host.js",
    "longname": "src/compiler-host.js~CompilerHost",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/compiler-host.js",
    "importStyle": "CompilerHost",
    "description": "This class is the top-level class that encapsulates all of the logic of \ncompiling and caching application code. If you're looking for a \"Main class\",\nthis is it.\n\nThis class can be created directly but it is usually created via the methods\nin config-parser, which will among other things, set up the compiler options\ngiven a project root.\n\nCompilerHost is also the top-level class that knows how to serialize all of the\ninformation necessary to recreate itself, either as a development host (i.e.\nwill allow cache misses and actual compilation), or as a read-only version of\nitself for production.",
    "lineNumber": 38,
    "interface": false
  },
  {
    "__docId__": 27,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#constructor",
    "access": null,
    "description": " \nCreates an instance of CompilerHost. You probably want to use the methods\nin config-parser for development, or {@link createReadonlyFromConfiguration}\nfor production instead.\n   ",
    "lineNumber": 65,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "The root directory to use for the cache"
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "compilers",
        "description": "an Object whose keys are input MIME types and\n                            whose values are instances of CompilerBase. Create\n                            this via the {@link createCompilers} method in\n                            config-parser."
      },
      {
        "nullable": null,
        "types": [
          "FileChangedCache"
        ],
        "spread": false,
        "optional": false,
        "name": "fileChangeCache",
        "description": "A file-change cache that is \n                                            optionally pre-loaded."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "readOnlyMode",
        "description": "If True, cache misses will fail and \n                                compilation will not be attempted."
      },
      {
        "nullable": null,
        "types": [
          "CompilerBase"
        ],
        "spread": false,
        "optional": false,
        "name": "fallbackCompiler",
        "description": "(optional)  When a file is compiled\n                                        which doesn't have a matching compiler,\n                                        this compiler will be used instead. If\n                                        null, will fail compilation. A good\n                                        alternate fallback is the compiler for\n                                        'text/plain', which is guaranteed to be\n                                        present."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 28,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "appRoot",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#appRoot",
    "access": null,
    "description": null,
    "lineNumber": 68,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 29,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "cachesForCompilers",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#cachesForCompilers",
    "access": null,
    "description": null,
    "lineNumber": 70,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 30,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "createReadonlyFromConfiguration",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost.createReadonlyFromConfiguration",
    "access": null,
    "description": "   \nCreates a production-mode CompilerHost from the previously saved \nconfiguration\n   ",
    "lineNumber": 100,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "The root directory to use for the cache. This\n                               cache must have cache information saved via\n                               {@link saveConfiguration}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "appRoot",
        "description": "The top-level directory for your application (i.e.\n                          the one which has your package.json)."
      },
      {
        "nullable": null,
        "types": [
          "CompilerBase"
        ],
        "spread": false,
        "optional": false,
        "name": "fallbackCompiler",
        "description": "(optional)  When a file is compiled\n                                        which doesn't have a matching compiler,\n                                        this compiler will be used instead. If\n                                        null, will fail compilation. A good\n                                        alternate fallback is the compiler for\n                                        'text/plain', which is guaranteed to be\n                                        present."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CompilerHost"
      ],
      "spread": false,
      "description": "A read-only CompilerHost"
    },
    "generator": false
  },
  {
    "__docId__": 31,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "createFromConfiguration",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost.createFromConfiguration",
    "access": null,
    "description": "   \nCreates a development-mode CompilerHost from the previously saved \nconfiguration.\n   ",
    "lineNumber": 144,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "The root directory to use for the cache. This\n                               cache must have cache information saved via\n                               {@link saveConfiguration}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "appRoot",
        "description": "The top-level directory for your application (i.e.\n                          the one which has your package.json)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "compilersByMimeType",
        "description": "an Object whose keys are input MIME \n                                      types and whose values are instances \n                                      of CompilerBase. Create this via the \n                                      {@link createCompilers} method in \n                                      config-parser."
      },
      {
        "nullable": null,
        "types": [
          "CompilerBase"
        ],
        "spread": false,
        "optional": false,
        "name": "fallbackCompiler",
        "description": "(optional)  When a file is compiled\n                                        which doesn't have a matching compiler,\n                                        this compiler will be used instead. If\n                                        null, will fail compilation. A good\n                                        alternate fallback is the compiler for\n                                        'text/plain', which is guaranteed to be\n                                        present."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CompilerHost"
      ],
      "spread": false,
      "description": "A read-only CompilerHost"
    },
    "generator": false
  },
  {
    "__docId__": 32,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "saveConfiguration",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#saveConfiguration",
    "access": null,
    "description": " \nSaves the current compiler configuration to a file that \n{@link createReadonlyFromConfiguration} can use to recreate the current \ncompiler environment\n   ",
    "lineNumber": 167,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion"
    },
    "generator": false
  },
  {
    "__docId__": 33,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compile",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compile",
    "access": null,
    "description": " \nCompiles a file and returns the compiled result.\n   ",
    "lineNumber": 207,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to the file to compile"
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "hashInfo",
        "description": "The hash information returned from getHashForPath"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "code",
        "description": "The source code if the file was a text file"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "binaryData",
        "description": "The file if it was a binary file"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mimeType",
        "description": "The MIME type saved in the cache."
      },
      {
        "nullable": null,
        "types": [
          "string[]"
        ],
        "spread": false,
        "optional": false,
        "name": "dependentFiles",
        "description": "The dependent files returned from \n                                     compiling the file, if any."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "object"
      ],
      "spread": false,
      "description": "An Object with the compiled result"
    },
    "generator": false
  },
  {
    "__docId__": 34,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileReadOnly",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compileReadOnly",
    "access": "private",
    "description": " \nHandles compilation in read-only mode",
    "lineNumber": 217,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 35,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fullCompile",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#fullCompile",
    "access": "private",
    "description": " \nHandles compilation in read-write mode",
    "lineNumber": 253,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 36,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileUncached",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compileUncached",
    "access": "private",
    "description": " \nHandles invoking compilers independent of caching",
    "lineNumber": 288,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      },
      {
        "name": "hashInfo",
        "types": [
          "*"
        ]
      },
      {
        "name": "compiler",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 37,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileAll",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compileAll",
    "access": null,
    "description": " \nPre-caches an entire directory of files recursively. Usually used for \nbuilding custom compiler tooling.\n   ",
    "lineNumber": 355,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootDirectory",
        "description": "The top-level directory to compile"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "shouldCompile",
        "description": "(optional)  A Function which allows the \n                                 caller to disable compiling certain files.\n                                 It takes a fully-qualified path to a file,\n                                 and should return a Boolean."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion."
    },
    "generator": false
  },
  {
    "__docId__": 38,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileSync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compileSync",
    "access": null,
    "description": null,
    "lineNumber": 370,
    "undocument": true,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 39,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "createReadonlyFromConfigurationSync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost.createReadonlyFromConfigurationSync",
    "access": null,
    "description": "   \nCreates a production-mode CompilerHost from the previously saved \nconfiguration\n   ",
    "lineNumber": 374,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "The root directory to use for the cache. This\n                               cache must have cache information saved via\n                               {@link saveConfiguration}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "appRoot",
        "description": "The top-level directory for your application (i.e.\n                          the one which has your package.json)."
      },
      {
        "nullable": null,
        "types": [
          "CompilerBase"
        ],
        "spread": false,
        "optional": false,
        "name": "fallbackCompiler",
        "description": "(optional)  When a file is compiled\n                                        which doesn't have a matching compiler,\n                                        this compiler will be used instead. If\n                                        null, will fail compilation. A good\n                                        alternate fallback is the compiler for\n                                        'text/plain', which is guaranteed to be\n                                        present."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CompilerHost"
      ],
      "spread": false,
      "description": "A read-only CompilerHost"
    },
    "generator": false
  },
  {
    "__docId__": 40,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "createFromConfigurationSync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost.createFromConfigurationSync",
    "access": null,
    "description": "   \nCreates a development-mode CompilerHost from the previously saved \nconfiguration.\n   ",
    "lineNumber": 391,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "The root directory to use for the cache. This\n                               cache must have cache information saved via\n                               {@link saveConfiguration}"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "appRoot",
        "description": "The top-level directory for your application (i.e.\n                          the one which has your package.json)."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "compilersByMimeType",
        "description": "an Object whose keys are input MIME \n                                      types and whose values are instances \n                                      of CompilerBase. Create this via the \n                                      {@link createCompilers} method in \n                                      config-parser."
      },
      {
        "nullable": null,
        "types": [
          "CompilerBase"
        ],
        "spread": false,
        "optional": false,
        "name": "fallbackCompiler",
        "description": "(optional)  When a file is compiled\n                                        which doesn't have a matching compiler,\n                                        this compiler will be used instead. If\n                                        null, will fail compilation. A good\n                                        alternate fallback is the compiler for\n                                        'text/plain', which is guaranteed to be\n                                        present."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CompilerHost"
      ],
      "spread": false,
      "description": "A read-only CompilerHost"
    },
    "generator": false
  },
  {
    "__docId__": 41,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "saveConfigurationSync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#saveConfigurationSync",
    "access": null,
    "description": " \nSaves the current compiler configuration to a file that \n{@link createReadonlyFromConfiguration} can use to recreate the current \ncompiler environment\n   ",
    "lineNumber": 406,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion"
    },
    "generator": false
  },
  {
    "__docId__": 42,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileReadOnlySync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compileReadOnlySync",
    "access": "private",
    "description": " \nHandles compilation in read-only mode",
    "lineNumber": 432,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 43,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "fullCompileSync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#fullCompileSync",
    "access": "private",
    "description": " \nHandles compilation in read-write mode",
    "lineNumber": 471,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 44,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileUncachedSync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compileUncachedSync",
    "access": "private",
    "description": " \nHandles invoking compilers independent of caching",
    "lineNumber": 501,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      },
      {
        "name": "hashInfo",
        "types": [
          "*"
        ]
      },
      {
        "name": "compiler",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 45,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileAllSync",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#compileAllSync",
    "access": null,
    "description": " \nPre-caches an entire directory of files recursively. Usually used for \nbuilding custom compiler tooling.\n   ",
    "lineNumber": 554,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootDirectory",
        "description": "The top-level directory to compile"
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": false,
        "name": "shouldCompile",
        "description": "(optional)  A Function which allows the \n                                 caller to disable compiling certain files.\n                                 It takes a fully-qualified path to a file,\n                                 and should return a Boolean."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion."
    },
    "generator": false
  },
  {
    "__docId__": 46,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getPassthroughCompiler",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost#getPassthroughCompiler",
    "access": "private",
    "description": "Returns the passthrough compiler ",
    "lineNumber": 573,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 47,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "shouldPassthrough",
    "memberof": "src/compiler-host.js~CompilerHost",
    "longname": "src/compiler-host.js~CompilerHost.shouldPassthrough",
    "access": "private",
    "description": "Determines whether we should even try to compile the content. Note that in\nsome cases, content will still be in cache even if this returns true, and\nin other cases (isInNodeModules), we'll know explicitly to not even bother\nlooking in the cache.\n   ",
    "lineNumber": 586,
    "params": [
      {
        "name": "hashInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 48,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/config-parser.js",
    "memberof": null,
    "longname": "src/config-parser.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\nimport fs from 'fs';\nimport path from 'path';\nimport mkdirp from 'mkdirp';\nimport {pfs} from './promise';\n\nimport FileChangedCache from './file-change-cache';\nimport CompilerHost from './compiler-host';\nimport { initializeProtocolHook } from './protocol-hook';\nimport registerRequireExtension from './require-hook';\n\nconst d = require('debug')('electron-compile:config-parser');\n\n// NB: We intentionally delay-load this so that in production, you can create\n// cache-only versions of these compilers\nlet allCompilerClasses = null;\n\nfunction statSyncNoException(fsPath) {\n  if ('statSyncNoException' in fs) {\n    return fs.statSyncNoException(fsPath);\n  }\n  \n  try {\n    return fs.statSync(fsPath);\n  } catch (e) {\n    return null;\n  }\n}\n\n\n/**\n * Initialize the global hooks (protocol hook for file:, node.js hook) \n * independent of initializing the compiler. This method is usually called by\n * init instead of directly\n * \n * @param {CompilerHost} compilerHost  The compiler host to use.\n *  \n */ \nexport function initializeGlobalHooks(compilerHost) {\n  const { app } = require('electron');\n  \n  registerRequireExtension(compilerHost);\n\n  let protoify = function() { initializeProtocolHook(compilerHost); };\n  if (app.isReady()) {\n    protoify();\n  } else {\n    app.on('ready', protoify);\n  }\n}\n\n\n/**\n * Initialize electron-compile and set it up, either for development or \n * production use. This is almost always the only method you need to use in order\n * to use electron-compile.\n *  \n * @param  {string} appRoot  The top-level directory for your application (i.e.\n *                           the one which has your package.json).\n *\n * @param  {string} mainModule  The module to require in, relative to the module\n *                              calling init, that will start your app. Write this \n *                              as if you were writing a require call from here.\n *\n * @param  {bool} productionMode   If explicitly True/False, will set read-only\n *                                 mode to be disabled/enabled. If not, we'll\n *                                 guess based on the presence of a production\n *                                 cache.\n */ \nexport function init(appRoot, mainModule, productionMode = null) {\n  let compilerHost = null;\n  let cacheDir = path.join(appRoot, '.cache');\n  \n  if (productionMode === null) {\n    productionMode = !!statSyncNoException(cacheDir);\n  }\n  \n  if (productionMode) {\n    // In read-only mode, we'll assume that everything is in `appRoot/.cache`\n    compilerHost = CompilerHost.createReadonlyFromConfigurationSync(cacheDir, appRoot);\n  } else {\n    compilerHost = createCompilerHostFromProjectRootSync(appRoot);\n  }\n  \n  initializeGlobalHooks(compilerHost);\n  require.main.require(mainModule);\n}\n\n\n/**\n * Creates a {@link CompilerHost} with the given information. This method is\n * usually called by {@link createCompilerHostFromProjectRoot}.\n *  \n * @private\n */ \nexport function createCompilerHostFromConfiguration(info) {\n  let compilers = createCompilers();\n  let rootCacheDir = info.rootCacheDir || calculateDefaultCompileCacheDirectory();\n  \n  d(`Creating CompilerHost: ${JSON.stringify(info)}, rootCacheDir = ${rootCacheDir}`);\n  let fileChangeCache = new FileChangedCache(info.appRoot);\n  let ret = new CompilerHost(rootCacheDir, compilers, fileChangeCache, false, compilers['text/plain']);\n  \n  _.each(Object.keys(info.options || {}), (x) => {\n    let opts = info.options[x];\n    if (!(x in compilers)) {\n      throw new Error(`Found compiler settings for missing compiler: ${x}`);\n    }\n    \n    d(`Setting options for ${x}: ${JSON.stringify(opts)}`);\n    compilers[x].compilerOptions = opts;\n  });\n  \n  // NB: It's super important that we guarantee that the configuration is saved\n  // out, because we'll need to re-read it in the renderer process\n  d(`Created compiler host with options: ${JSON.stringify(info)}`);\n  ret.saveConfigurationSync();\n  return ret;\n}\n\n/**\n * Creates a compiler host from a .babelrc file. This method is usually called\n * from {@link createCompilerHostFromProjectRoot} instead of used directly.\n *  \n * @param  {string} file  The path to a .babelrc file\n *\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\n *\n * @return {Promise<CompilerHost>}  A set-up compiler host\n */ \nexport async function createCompilerHostFromBabelRc(file, rootCacheDir=null) {\n  let info = JSON.parse(await pfs.readFile(file, 'utf8'));\n  \n  // package.json\n  if ('babel' in info) {\n    info = info.babel;\n  }\n  \n  if ('env' in info) {\n    let ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';\n    info = info.env[ourEnv];\n  }\n  \n  // Are we still package.json (i.e. is there no babel info whatsoever?)\n  if ('name' in info && 'version' in info) {\n    return createCompilerHostFromConfiguration({\n      appRoot: path.dirname(file),\n      options: getDefaultConfiguration(),\n      rootCacheDir\n    });\n  }\n  \n  return createCompilerHostFromConfiguration({\n    appRoot: path.dirname(file),\n    options: {\n      'application/javascript': info\n    },\n    rootCacheDir\n  });\n}\n\n\n/**\n * Creates a compiler host from a .compilerc file. This method is usually called\n * from {@link createCompilerHostFromProjectRoot} instead of used directly.\n *  \n * @param  {string} file  The path to a .compilerc file\n *\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\n *\n * @return {Promise<CompilerHost>}  A set-up compiler host\n */ \nexport async function createCompilerHostFromConfigFile(file, rootCacheDir=null) {\n  let info = JSON.parse(await pfs.readFile(file, 'utf8'));\n  \n  if ('env' in info) {\n    let ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';\n    info = info.env[ourEnv];\n  }\n  \n  return createCompilerHostFromConfiguration({\n    appRoot: path.dirname(file),\n    options: info,\n    rootCacheDir\n  });\n}\n\n\n/**\n * Creates a configured {@link CompilerHost} instance from the project root \n * directory. This method first searches for a .compilerc, then falls back to the\n * default locations for Babel configuration info. If neither are found, defaults\n * to standard settings\n *  \n * @param  {string} rootDir  The root application directory (i.e. the directory\n *                           that has the app's package.json)\n *\n * @param  {string} rootCacheDir (optional)  The directory to use as a cache.\n *\n * @return {Promise<CompilerHost>}  A set-up compiler host\n */ \nexport async function createCompilerHostFromProjectRoot(rootDir, rootCacheDir=null) {\n  let compilerc = path.join(rootDir, '.compilerc');\n  if (statSyncNoException(compilerc)) {\n    d(`Found a .compilerc at ${compilerc}, using it`);\n    return await createCompilerHostFromConfigFile(compilerc, rootCacheDir);\n  }\n  \n  let babelrc = path.join(rootDir, '.babelrc');\n  if (statSyncNoException(babelrc)) {\n    d(`Found a .babelrc at ${babelrc}, using it`);\n    return await createCompilerHostFromBabelRc(babelrc, rootCacheDir);\n  }\n    \n  d(`Using package.json or default parameters at ${rootDir}`);\n  return await createCompilerHostFromBabelRc(path.join(rootDir, 'package.json'), rootCacheDir);\n}\n\nexport function createCompilerHostFromBabelRcSync(file, rootCacheDir=null) {\n  let info = JSON.parse(fs.readFileSync(file, 'utf8'));\n  \n  // package.json\n  if ('babel' in info) {\n    info = info.babel;\n  }\n  \n  if ('env' in info) {\n    let ourEnv = process.env.BABEL_ENV || process.env.NODE_ENV || 'development';\n    info = info.env[ourEnv];\n  }\n  \n  // Are we still package.json (i.e. is there no babel info whatsoever?)\n  if ('name' in info && 'version' in info) {\n    return createCompilerHostFromConfiguration({\n      appRoot: path.dirname(file),\n      options: getDefaultConfiguration(),\n      rootCacheDir\n    });\n  }\n  \n  return createCompilerHostFromConfiguration({\n    appRoot: path.dirname(file),\n    options: {\n      'application/javascript': info\n    },\n    rootCacheDir\n  });\n}\n\nexport function createCompilerHostFromConfigFileSync(file, rootCacheDir=null) {\n  let info = JSON.parse(fs.readFileSync(file, 'utf8'));\n  \n  if ('env' in info) {\n    let ourEnv = process.env.ELECTRON_COMPILE_ENV || process.env.NODE_ENV || 'development';\n    info = info.env[ourEnv];\n  }\n  \n  return createCompilerHostFromConfiguration({\n    appRoot: path.dirname(file),\n    options: info,\n    rootCacheDir\n  });\n}\n\nexport function createCompilerHostFromProjectRootSync(rootDir, rootCacheDir=null) {\n  let compilerc = path.join(rootDir, '.compilerc');\n  if (statSyncNoException(compilerc)) {\n    d(`Found a .compilerc at ${compilerc}, using it`);\n    return createCompilerHostFromConfigFileSync(compilerc, rootCacheDir);\n  }\n  \n  let babelrc = path.join(rootDir, '.babelrc');\n  if (statSyncNoException(babelrc)) {\n    d(`Found a .babelrc at ${babelrc}, using it`);\n    return createCompilerHostFromBabelRcSync(babelrc, rootCacheDir);\n  }\n    \n  d(`Using package.json or default parameters at ${rootDir}`);\n  return createCompilerHostFromBabelRcSync(path.join(rootDir, 'package.json'), rootCacheDir);\n}\n\n/**\n * Returns what electron-compile would use as a default rootCacheDir. Usually only\n * used for debugging purposes\n *  \n * @return {string}  A path that may or may not exist where electron-compile would\n *                   set up a development mode cache.\n */ \nexport function calculateDefaultCompileCacheDirectory() {\n  let tmpDir = process.env.TEMP || process.env.TMPDIR || '/tmp';\n  let hash = require('crypto').createHash('md5').update(process.execPath).digest('hex');\n\n  let cacheDir = path.join(tmpDir, `compileCache_${hash}`);\n  mkdirp.sync(cacheDir);\n  \n  d(`Using default cache directory: ${cacheDir}`);\n  return cacheDir;\n}\n\n\n/**\n * Returns the default .configrc if no configuration information can be found.\n *  \n * @return {Object}  A list of default config settings for electron-compiler.\n */ \nexport function getDefaultConfiguration() {\n  return {\n    'application/javascript': {\n      \"presets\": [\"stage-0\", \"es2015\"],\n      \"sourceMaps\": \"inline\"\n    }\n  };\n}\n\n/**\n * Allows you to create new instances of all compilers that are supported by \n * electron-compile and use them directly. Currently supports Babel, CoffeeScript, \n * TypeScript, LESS, and Jade.\n *  \n * @return {Object}  An Object whose Keys are MIME types, and whose values \n * are instances of @{link CompilerBase}.\n */ \nexport function createCompilers() {\n  if (!allCompilerClasses) {\n    // First we want to see if electron-compilers itself has been installed with\n    // devDependencies. If that's not the case, check to see if\n    // electron-compilers is installed as a peer dependency (probably as a\n    // devDependency of the root project).\n    const locations = ['electron-compilers', '../../electron-compilers'];\n\n    for (let location of locations) {\n      try {\n        allCompilerClasses = require(location);\n      } catch (e) {\n        // Yolo\n      }\n    }\n\n    if (!allCompilerClasses) {\n      throw new Error(\"Electron compilers not found but were requested to be loaded\");\n    }\n  }\n\n  // NB: Note that this code is carefully set up so that InlineHtmlCompiler \n  // (i.e. classes with `createFromCompilers`) initially get an empty object,\n  // but will have a reference to the final result of what we return, which\n  // resolves the circular dependency we'd otherwise have here.\n  let ret = {};\n  let instantiatedClasses = _.map(allCompilerClasses, (Klass) => {\n    if ('createFromCompilers' in Klass) {\n      return Klass.createFromCompilers(ret);\n    } else {\n      return new Klass();\n    }\n  });\n\n  _.reduce(instantiatedClasses, (acc,x) => {\n    let Klass = Object.getPrototypeOf(x).constructor;\n\n    for (let type of Klass.getInputMimeTypes()) { acc[type] = x; }\n    return acc;\n  }, ret);\n  \n  return ret;\n}\n"
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "d",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~d",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 50,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "allCompilerClasses",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~allCompilerClasses",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 51,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "statSyncNoException",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~statSyncNoException",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 18,
    "undocument": true,
    "params": [
      {
        "name": "fsPath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 52,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "initializeGlobalHooks",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~initializeGlobalHooks",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{initializeGlobalHooks}",
    "description": "Initialize the global hooks (protocol hook for file:, node.js hook) \nindependent of initializing the compiler. This method is usually called by\ninit instead of directly",
    "lineNumber": 39,
    "params": [
      {
        "nullable": null,
        "types": [
          "CompilerHost"
        ],
        "spread": false,
        "optional": false,
        "name": "compilerHost",
        "description": "The compiler host to use."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 53,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "init",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~init",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{init}",
    "description": "Initialize electron-compile and set it up, either for development or \nproduction use. This is almost always the only method you need to use in order\nto use electron-compile.\n ",
    "lineNumber": 70,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "appRoot",
        "description": "The top-level directory for your application (i.e.\n                          the one which has your package.json)."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "mainModule",
        "description": "The module to require in, relative to the module\n                             calling init, that will start your app. Write this \n                             as if you were writing a require call from here."
      },
      {
        "nullable": null,
        "types": [
          "bool"
        ],
        "spread": false,
        "optional": false,
        "name": "productionMode",
        "description": "If explicitly True/False, will set read-only\n                                mode to be disabled/enabled. If not, we'll\n                                guess based on the presence of a production\n                                cache."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 54,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilerHostFromConfiguration",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilerHostFromConfiguration",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilerHostFromConfiguration}",
    "description": "Creates a {@link CompilerHost} with the given information. This method is\nusually called by {@link createCompilerHostFromProjectRoot}.\n ",
    "lineNumber": 96,
    "params": [
      {
        "name": "info",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 55,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilerHostFromBabelRc",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilerHostFromBabelRc",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilerHostFromBabelRc}",
    "description": "Creates a compiler host from a .babelrc file. This method is usually called\nfrom {@link createCompilerHostFromProjectRoot} instead of used directly.\n ",
    "lineNumber": 131,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The path to a .babelrc file"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "(optional)  The directory to use as a cache."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<CompilerHost>"
      ],
      "spread": false,
      "description": "A set-up compiler host"
    },
    "generator": false
  },
  {
    "__docId__": 56,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilerHostFromConfigFile",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilerHostFromConfigFile",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilerHostFromConfigFile}",
    "description": "Creates a compiler host from a .compilerc file. This method is usually called\nfrom {@link createCompilerHostFromProjectRoot} instead of used directly.\n ",
    "lineNumber": 173,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "The path to a .compilerc file"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "(optional)  The directory to use as a cache."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<CompilerHost>"
      ],
      "spread": false,
      "description": "A set-up compiler host"
    },
    "generator": false
  },
  {
    "__docId__": 57,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilerHostFromProjectRoot",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilerHostFromProjectRoot",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilerHostFromProjectRoot}",
    "description": "Creates a configured {@link CompilerHost} instance from the project root \ndirectory. This method first searches for a .compilerc, then falls back to the\ndefault locations for Babel configuration info. If neither are found, defaults\nto standard settings\n ",
    "lineNumber": 202,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootDir",
        "description": "The root application directory (i.e. the directory\n                          that has the app's package.json)"
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "rootCacheDir",
        "description": "(optional)  The directory to use as a cache."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<CompilerHost>"
      ],
      "spread": false,
      "description": "A set-up compiler host"
    },
    "generator": false
  },
  {
    "__docId__": 58,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilerHostFromBabelRcSync",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilerHostFromBabelRcSync",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilerHostFromBabelRcSync}",
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "params": [
      {
        "name": "file",
        "types": [
          "*"
        ]
      },
      {
        "name": "rootCacheDir",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 59,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilerHostFromConfigFileSync",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilerHostFromConfigFileSync",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilerHostFromConfigFileSync}",
    "description": null,
    "lineNumber": 250,
    "undocument": true,
    "params": [
      {
        "name": "file",
        "types": [
          "*"
        ]
      },
      {
        "name": "rootCacheDir",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 60,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilerHostFromProjectRootSync",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilerHostFromProjectRootSync",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilerHostFromProjectRootSync}",
    "description": null,
    "lineNumber": 265,
    "undocument": true,
    "params": [
      {
        "name": "rootDir",
        "types": [
          "*"
        ]
      },
      {
        "name": "rootCacheDir",
        "optional": true,
        "types": [
          "*"
        ],
        "defaultRaw": null,
        "defaultValue": "null"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 61,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "calculateDefaultCompileCacheDirectory",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~calculateDefaultCompileCacheDirectory",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{calculateDefaultCompileCacheDirectory}",
    "description": "Returns what electron-compile would use as a default rootCacheDir. Usually only\nused for debugging purposes\n ",
    "lineNumber": 289,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": "A path that may or may not exist where electron-compile would\n                  set up a development mode cache."
    },
    "generator": false
  },
  {
    "__docId__": 62,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "getDefaultConfiguration",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~getDefaultConfiguration",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{getDefaultConfiguration}",
    "description": "Returns the default .configrc if no configuration information can be found.\n ",
    "lineNumber": 306,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "A list of default config settings for electron-compiler."
    },
    "generator": false
  },
  {
    "__docId__": 63,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createCompilers",
    "memberof": "src/config-parser.js",
    "longname": "src/config-parser.js~createCompilers",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/config-parser.js",
    "importStyle": "{createCompilers}",
    "description": "Allows you to create new instances of all compilers that are supported by \nelectron-compile and use them directly. Currently supports Babel, CoffeeScript, \nTypeScript, LESS, and Jade.\n ",
    "lineNumber": 323,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "An Object whose Keys are MIME types, and whose values \nare instances of @{link CompilerBase}."
    },
    "generator": false
  },
  {
    "__docId__": 64,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/digest-for-object.js",
    "memberof": null,
    "longname": "src/digest-for-object.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import crypto from 'crypto';\n\nfunction updateDigestForJsonValue(shasum, value) {\n  // Implmentation is similar to that of pretty-printing a JSON object, except:\n  // * Strings are not escaped.\n  // * No effort is made to avoid trailing commas.\n  // These shortcuts should not affect the correctness of this function.\n  const type = typeof(value);\n\n  if (type === 'string') {\n    shasum.update('\"', 'utf8');\n    shasum.update(value, 'utf8');\n    shasum.update('\"', 'utf8');\n    return;\n  }\n\n  if (type === 'boolean' || type === 'number') {\n    shasum.update(value.toString(), 'utf8');\n    return;\n  }\n\n  if (!value) {\n    shasum.update('null', 'utf8');\n    return;\n  }\n\n  if (Array.isArray(value)) {\n    shasum.update('[', 'utf8');\n    for (let i=0; i < value.length; i++) {\n      updateDigestForJsonValue(shasum, value[i]);\n      shasum.update(',', 'utf8');\n    }\n    shasum.update(']', 'utf8');\n    return;\n  }\n\n  // value must be an object: be sure to sort the keys.\n  let keys = Object.keys(value);\n  keys.sort();\n\n  shasum.update('{', 'utf8');\n\n  for (let i=0; i < keys.length; i++) {\n    updateDigestForJsonValue(shasum, keys[i]);\n    shasum.update(': ', 'utf8');\n    updateDigestForJsonValue(shasum, value[keys[i]]);\n    shasum.update(',', 'utf8');\n  }\n\n  shasum.update('}', 'utf8');\n}\n\n\n/**\n * Creates a hash from a JS object\n * \n * @private  \n */ \nexport default function createDigestForObject(obj) {\n  let sha1 = crypto.createHash('sha1');\n  updateDigestForJsonValue(sha1, obj);\n  \n  return sha1.digest('hex');\n}\n"
  },
  {
    "__docId__": 65,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "updateDigestForJsonValue",
    "memberof": "src/digest-for-object.js",
    "longname": "src/digest-for-object.js~updateDigestForJsonValue",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/digest-for-object.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "shasum",
        "types": [
          "*"
        ]
      },
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 66,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "createDigestForObject",
    "memberof": "src/digest-for-object.js",
    "longname": "src/digest-for-object.js~createDigestForObject",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/digest-for-object.js",
    "importStyle": "createDigestForObject",
    "description": "Creates a hash from a JS object",
    "lineNumber": 59,
    "params": [
      {
        "name": "obj",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 67,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/file-change-cache.js",
    "memberof": null,
    "longname": "src/file-change-cache.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import fs from 'fs';\nimport zlib from 'zlib';\nimport crypto from 'crypto';\nimport {pfs, pzlib} from './promise';\nimport _ from 'lodash';\n\nconst d = require('debug')('electron-compile:file-change-cache');\n\n/**\n * This class caches information about files and determines whether they have\n * changed contents or not. Most importantly, this class caches the hash of seen\n * files so that at development time, we don't have to recalculate them constantly.\n * \n * This class is also the core of how electron-compile runs quickly in production\n * mode - after precompilation, the cache is serialized along with the rest of the\n * data in {@link CompilerHost}, so that when we load the app in production mode,\n * we don't end up calculating hashes of file content at all, only using the contents\n * of this cache.\n */ \nexport default class FileChangedCache {\n  constructor(appRoot, failOnCacheMiss=false) {\n    this.appRoot = appRoot;\n    this.failOnCacheMiss = failOnCacheMiss;\n    this.changeCache = {};\n  }\n  \n  /**  \n   * Allows you to create a FileChangedCache from serialized data saved from \n   * {@link getSavedData}.\n   *    \n   * @param  {Object} data  Saved data from getSavedData.\n   * \n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   * \n   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.\n   * \n   * @return {FileChangedCache}\n   */   \n  static loadFromData(data, appRoot, failOnCacheMiss=true) {\n    let ret = new FileChangedCache(appRoot, failOnCacheMiss);\n    ret.changeCache = data.changeCache;\n    ret.originalAppRoot = data.appRoot;\n\n    return ret;\n  }\n\n\n  /**  \n   * Allows you to create a FileChangedCache from serialized data saved from \n   * {@link save}.\n   *    \n   * @param  {string} file  Saved data from save.\n   * \n   * @param  {string} appRoot  The top-level directory for your application (i.e.\n   *                           the one which has your package.json).\n   * \n   * @param  {boolean} failOnCacheMiss (optional)  If True, cache misses will throw.\n   * \n   * @return {Promise<FileChangedCache>}\n   */\n  static async loadFromFile(file, appRoot, failOnCacheMiss=true) {\n    d(`Loading canned FileChangedCache from ${file}`);\n  \n    let buf = await pfs.readFile(file);\n    return FileChangedCache.loadFromData(JSON.parse(await pzlib.gunzip(buf)), appRoot, failOnCacheMiss);\n  }\n  \n  \n  /**  \n   * Returns information about a given file, including its hash. This method is\n   * the main method for this cache.\n   *    \n   * @param  {string} absoluteFilePath  The path to a file to retrieve info on.\n   * \n   * @return {Promise<Object>}\n   * \n   * @property {string} hash  The SHA1 hash of the file\n   * @property {boolean} isMinified  True if the file is minified\n   * @property {boolean} isInNodeModules  True if the file is in a library directory\n   * @property {boolean} hasSourceMap  True if the file has a source map\n   * @property {boolean} isFileBinary  True if the file is not a text file\n   * @property {Buffer} binaryData (optional)  The buffer that was read if the file\n   *                                           was binary and there was a cache miss.\n   * @property {string} code (optional)  The string that was read if the file\n   *                                     was text and there was a cache miss\n   */   \n  async getHashForPath(absoluteFilePath) {\n    let cacheKey = absoluteFilePath;\n    if (this.appRoot) {\n      cacheKey = absoluteFilePath.replace(this.appRoot, '');\n    } \n    \n    // NB: We do this because x-require will include an absolute path from the \n    // original built app and we need to still grok it\n    if (this.originalAppRoot) {\n      cacheKey = cacheKey.replace(this.originalAppRoot, '');\n    }\n    \n    let cacheEntry = this.changeCache[cacheKey];\n    \n    if (this.failOnCacheMiss) {\n      if (!cacheEntry) {\n        d(`Tried to read file cache entry for ${absoluteFilePath}`);\n        d(`cacheKey: ${cacheKey}, appRoot: ${this.appRoot}, originalAppRoot: ${this.originalAppRoot}`);\n        throw new Error(`Asked for ${absoluteFilePath} but it was not precompiled!`);\n      }\n\n      return cacheEntry.info;\n    }\n        \n    let stat = await pfs.stat(absoluteFilePath);\n    let ctime = stat.ctime.getTime();\n    let size = stat.size;\n    if (!stat || !stat.isFile()) throw new Error(`Can't stat ${absoluteFilePath}`);\n    \n    if (cacheEntry) {\n      if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {\n        return cacheEntry.info;\n      }\n      \n      d(`Invalidating cache entry: ${cacheEntry.ctime} === ${ctime} && ${cacheEntry.size} === ${size}`);\n      delete this.changeCache.cacheEntry;\n    }\n    \n    let {digest, sourceCode, binaryData} = await this.calculateHashForFile(absoluteFilePath);\n    \n    let info = {\n      hash: digest,\n      isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),\n      isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),\n      hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),\n      isFileBinary: !!binaryData\n    };\n    \n    this.changeCache[cacheKey] = { ctime, size, info };\n    d(`Cache entry for ${cacheKey}: ${JSON.stringify(this.changeCache[cacheKey])}`);\n\n    if (binaryData) {\n      return _.extend({binaryData}, info);\n    } else {\n      return _.extend({sourceCode}, info);\n    }\n  }\n  \n  \n  /**  \n   * Returns data that can passed to {@link loadFromData} to rehydrate this cache.\n   *    \n   * @return {Object}\n   */   \n  getSavedData() {\n    return { changeCache: this.changeCache, appRoot: this.appRoot };\n  }\n    \n  /**  \n   * Serializes this object's data to a file.\n   *\n   * @param {string} filePath  The path to save data to.\n   *    \n   * @return {Promise} Completion.\n   */   \n  async save(filePath) {\n    let toSave = this.getSavedData();\n    \n    let buf = await pzlib.gzip(new Buffer(JSON.stringify(toSave)));\n    await pfs.writeFile(filePath, buf);\n  }\n  \n  async calculateHashForFile(absoluteFilePath) {\n    let buf = await pfs.readFile(absoluteFilePath);\n    let encoding = FileChangedCache.detectFileEncoding(buf);\n    \n    if (!encoding) {\n      let digest = crypto.createHash('sha1').update(buf).digest('hex');\n      return { sourceCode: null, digest, binaryData: buf };\n    }\n    \n    let sourceCode = await pfs.readFile(absoluteFilePath, encoding);\n    let digest = crypto.createHash('sha1').update(sourceCode, 'utf8').digest('hex');\n    \n    return {sourceCode, digest, binaryData: null };\n  }\n  \n  getHashForPathSync(absoluteFilePath) {\n    let cacheKey = this.appRoot ? absoluteFilePath.replace(this.appRoot, '') : absoluteFilePath;\n    let cacheEntry = this.changeCache[cacheKey];\n    \n    if (this.failOnCacheMiss) {\n      if (!cacheEntry) {\n        d(`Tried to read file cache entry for ${absoluteFilePath}`);\n        d(`cacheKey: ${cacheKey}, appRoot: ${this.appRoot}, originalAppRoot: ${this.originalAppRoot}`);\n        throw new Error(`Asked for ${absoluteFilePath} but it was not precompiled!`);\n      }\n\n      return cacheEntry.info;\n    }\n        \n    let stat = fs.statSync(absoluteFilePath);\n    let ctime = stat.ctime.getTime();\n    let size = stat.size;\n    if (!stat || !stat.isFile()) throw new Error(`Can't stat ${absoluteFilePath}`);\n    \n    if (cacheEntry) {\n      if (cacheEntry.ctime >= ctime && cacheEntry.size === size) {\n        return cacheEntry.info;\n      }\n      \n      d(`Invalidating cache entry: ${cacheEntry.ctime} === ${ctime} && ${cacheEntry.size} === ${size}`);\n      delete this.changeCache.cacheEntry;\n    }\n    \n    let {digest, sourceCode, binaryData} = this.calculateHashForFileSync(absoluteFilePath);\n    \n    let info = {\n      hash: digest,\n      isMinified: FileChangedCache.contentsAreMinified(sourceCode || ''),\n      isInNodeModules: FileChangedCache.isInNodeModules(absoluteFilePath),\n      hasSourceMap: FileChangedCache.hasSourceMap(sourceCode || ''),\n      isFileBinary: !!binaryData\n    };\n    \n    this.changeCache[cacheKey] = { ctime, size, info };\n    d(`Cache entry for ${cacheKey}: ${JSON.stringify(this.changeCache[cacheKey])}`);\n\n    if (binaryData) {\n      return _.extend({binaryData}, info);\n    } else {\n      return _.extend({sourceCode}, info);\n    }  \n  }\n    \n  saveSync(filePath) {\n    let toSave = this.getSavedData();\n\n    let buf = zlib.gzipSync(new Buffer(JSON.stringify(toSave)));\n    fs.writeFileSync(filePath, buf);\n  }\n    \n  calculateHashForFileSync(absoluteFilePath) {\n    let buf = fs.readFileSync(absoluteFilePath);\n    let encoding = FileChangedCache.detectFileEncoding(buf);\n    \n    if (!encoding) {\n      let digest = crypto.createHash('sha1').update(buf).digest('hex');\n      return { sourceCode: null, digest, binaryData: buf};\n    }\n    \n    let sourceCode = fs.readFileSync(absoluteFilePath, encoding);\n    let digest = crypto.createHash('sha1').update(sourceCode, 'utf8').digest('hex');\n    \n    return {sourceCode, digest, binaryData: null};  \n  }\n  \n  \n  /**  \n   * Determines via some statistics whether a file is likely to be minified.\n   *\n   * @private\n   */   \n  static contentsAreMinified(source) {\n    let length = source.length;\n    if (length > 1024) length = 1024;\n\n    let newlineCount = 0;\n\n    // Roll through the characters and determine the average line length\n    for(let i=0; i < source.length; i++) {\n      if (source[i] === '\\n') newlineCount++;\n    }\n\n    // No Newlines? Any file other than a super small one is minified\n    if (newlineCount === 0) {\n      return (length > 80);\n    }\n\n    let avgLineLength = length / newlineCount;\n    return (avgLineLength > 80);\n  }\n\n  \n  /**  \n   * Determines whether a path is in node_modules or the Electron init code\n   *    \n   * @private\n   */   \n  static isInNodeModules(filePath) {\n    return !!(filePath.match(/node_modules[\\\\\\/]/i) || filePath.match(/atom\\.asar/));\n  }\n\n\n  /**\n   * Returns whether a file has an inline source map\n   *    \n   * @private\n   */   \n  static hasSourceMap(sourceCode) {\n    return sourceCode.lastIndexOf('//# sourceMap') > sourceCode.lastIndexOf('\\n');\n  }\n  \n  /**  \n   * Determines the encoding of a file from the two most common encodings by trying\n   * to decode it then looking for encoding errors\n   *\n   * @private\n   */   \n  static detectFileEncoding(buffer) {\n    if (buffer.length < 1) return false;\n    let buf = (buffer.length < 4096 ? buffer : buffer.slice(0, 4096));\n    \n    const encodings = ['utf8', 'utf16le'];\n    \n    let encoding = _.find(\n      encodings, \n      (x) => !FileChangedCache.containsControlCharacters(buf.toString(x)));\n    \n    return encoding;\n  }\n  \n  /**  \n   * Determines whether a string is likely to be poorly encoded by looking for\n   * control characters above a certain threshold\n   *\n   * @private\n   */   \n  static containsControlCharacters(str) {\n    let controlCount = 0;\n    let threshold = (str.length < 64 ? 2 : 16);\n    \n    for (let i=0; i < str.length; i++) {\n      let c = str.charCodeAt(i);\n      if (c === 65536 || c < 8) controlCount++;\n      \n      if (controlCount > threshold) return true;\n    }\n    \n    if (controlCount === 0) return false;\n    return (controlCount / str.length) < 0.02;\n  }\n}\n"
  },
  {
    "__docId__": 68,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "d",
    "memberof": "src/file-change-cache.js",
    "longname": "src/file-change-cache.js~d",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/file-change-cache.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "FileChangedCache",
    "memberof": "src/file-change-cache.js",
    "longname": "src/file-change-cache.js~FileChangedCache",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/file-change-cache.js",
    "importStyle": "FileChangedCache",
    "description": "This class caches information about files and determines whether they have\nchanged contents or not. Most importantly, this class caches the hash of seen\nfiles so that at development time, we don't have to recalculate them constantly.\n\nThis class is also the core of how electron-compile runs quickly in production\nmode - after precompilation, the cache is serialized along with the rest of the\ndata in {@link CompilerHost}, so that when we load the app in production mode,\nwe don't end up calculating hashes of file content at all, only using the contents\nof this cache.",
    "lineNumber": 20,
    "interface": false
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#constructor",
    "access": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "params": [
      {
        "name": "appRoot",
        "types": [
          "*"
        ]
      },
      {
        "name": "failOnCacheMiss",
        "optional": true,
        "types": [
          "boolean"
        ],
        "defaultRaw": false,
        "defaultValue": "false"
      }
    ],
    "generator": false
  },
  {
    "__docId__": 71,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "appRoot",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#appRoot",
    "access": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "failOnCacheMiss",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#failOnCacheMiss",
    "access": null,
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "static": false,
    "variation": null,
    "name": "changeCache",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#changeCache",
    "access": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "loadFromData",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache.loadFromData",
    "access": null,
    "description": " \nAllows you to create a FileChangedCache from serialized data saved from \n{@link getSavedData}.\n   ",
    "lineNumber": 40,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "data",
        "description": "Saved data from getSavedData."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "appRoot",
        "description": "The top-level directory for your application (i.e.\n                          the one which has your package.json)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "failOnCacheMiss",
        "description": "(optional)  If True, cache misses will throw."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FileChangedCache"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 75,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "loadFromFile",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache.loadFromFile",
    "access": null,
    "description": " \nAllows you to create a FileChangedCache from serialized data saved from \n{@link save}.\n   ",
    "lineNumber": 62,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "file",
        "description": "Saved data from save."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "appRoot",
        "description": "The top-level directory for your application (i.e.\n                          the one which has your package.json)."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "failOnCacheMiss",
        "description": "(optional)  If True, cache misses will throw."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "FileChangedCache"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 76,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHashForPath",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#getHashForPath",
    "access": null,
    "description": " \nReturns information about a given file, including its hash. This method is\nthe main method for this cache.\n   ",
    "lineNumber": 88,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "absoluteFilePath",
        "description": "The path to a file to retrieve info on."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "The SHA1 hash of the file"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isMinified",
        "description": "True if the file is minified"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isInNodeModules",
        "description": "True if the file is in a library directory"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "hasSourceMap",
        "description": "True if the file has a source map"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isFileBinary",
        "description": "True if the file is not a text file"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "binaryData",
        "description": "(optional)  The buffer that was read if the file\n                                          was binary and there was a cache miss."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "code",
        "description": "(optional)  The string that was read if the file\n                                    was text and there was a cache miss"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 77,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getSavedData",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#getSavedData",
    "access": null,
    "description": " \nReturns data that can passed to {@link loadFromData} to rehydrate this cache.\n   ",
    "lineNumber": 152,
    "params": [],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 78,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "save",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#save",
    "access": null,
    "description": " \nSerializes this object's data to a file.",
    "lineNumber": 163,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to save data to."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion."
    },
    "generator": false
  },
  {
    "__docId__": 79,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "calculateHashForFile",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#calculateHashForFile",
    "access": null,
    "description": null,
    "lineNumber": 170,
    "undocument": true,
    "params": [
      {
        "name": "absoluteFilePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 80,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getHashForPathSync",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#getHashForPathSync",
    "access": null,
    "description": " \nReturns information about a given file, including its hash. This method is\nthe main method for this cache.\n   ",
    "lineNumber": 185,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "absoluteFilePath",
        "description": "The path to a file to retrieve info on."
      }
    ],
    "properties": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "hash",
        "description": "The SHA1 hash of the file"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isMinified",
        "description": "True if the file is minified"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isInNodeModules",
        "description": "True if the file is in a library directory"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "hasSourceMap",
        "description": "True if the file has a source map"
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": false,
        "name": "isFileBinary",
        "description": "True if the file is not a text file"
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": false,
        "name": "binaryData",
        "description": "(optional)  The buffer that was read if the file\n                                          was binary and there was a cache miss."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "code",
        "description": "(optional)  The string that was read if the file\n                                    was text and there was a cache miss"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": ""
    },
    "generator": false
  },
  {
    "__docId__": 81,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "saveSync",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#saveSync",
    "access": null,
    "description": " \nSerializes this object's data to a file.",
    "lineNumber": 233,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "filePath",
        "description": "The path to save data to."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Completion."
    },
    "generator": false
  },
  {
    "__docId__": 82,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "calculateHashForFileSync",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache#calculateHashForFileSync",
    "access": null,
    "description": null,
    "lineNumber": 240,
    "undocument": true,
    "params": [
      {
        "name": "absoluteFilePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 83,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "contentsAreMinified",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache.contentsAreMinified",
    "access": "private",
    "description": " \nDetermines via some statistics whether a file is likely to be minified.",
    "lineNumber": 261,
    "params": [
      {
        "name": "source",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 84,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "isInNodeModules",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache.isInNodeModules",
    "access": "private",
    "description": " \nDetermines whether a path is in node_modules or the Electron init code\n   ",
    "lineNumber": 287,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 85,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "hasSourceMap",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache.hasSourceMap",
    "access": "private",
    "description": "Returns whether a file has an inline source map\n   ",
    "lineNumber": 297,
    "params": [
      {
        "name": "sourceCode",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 86,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "detectFileEncoding",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache.detectFileEncoding",
    "access": "private",
    "description": " \nDetermines the encoding of a file from the two most common encodings by trying\nto decode it then looking for encoding errors",
    "lineNumber": 307,
    "params": [
      {
        "name": "buffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 87,
    "kind": "method",
    "static": true,
    "variation": null,
    "name": "containsControlCharacters",
    "memberof": "src/file-change-cache.js~FileChangedCache",
    "longname": "src/file-change-cache.js~FileChangedCache.containsControlCharacters",
    "access": "private",
    "description": " \nDetermines whether a string is likely to be poorly encoded by looking for\ncontrol characters above a certain threshold",
    "lineNumber": 326,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 88,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/for-all-files.js",
    "memberof": null,
    "longname": "src/for-all-files.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\nimport fs from 'fs';\nimport path from 'path';\nimport {pfs} from './promise';\n\n\n/**\n * Invokes a method on all files in a directory recursively.\n * \n * @private\n */ \nexport function forAllFiles(rootDirectory, func, ...args) {\n  let rec = async (dir) => {\n    let entries = await pfs.readdir(dir);\n    \n    for (let name of entries) {\n      let fullName = path.join(dir, name);\n      let stats = await pfs.stat(fullName);\n\n      if (stats.isDirectory()) {\n        await rec(fullName);\n      }\n\n      if (stats.isFile()) {\n        await func(fullName, ...args);\n      }\n    }\n  };\n\n  return rec(rootDirectory);\n}\n\nexport function forAllFilesSync(rootDirectory, func, ...args) {\n  let rec = (dir) => {\n    _.each(fs.readdirSync(dir), (name) => {\n      let fullName = path.join(dir, name);\n      let stats = fs.statSync(fullName);\n      \n      if (stats.isDirectory()) {\n        rec(fullName);\n        return;\n      }\n      \n      if (stats.isFile()) {\n        func(fullName, ...args);\n        return;\n      }\n    });\n  };\n  \n  rec(rootDirectory);\n}\n"
  },
  {
    "__docId__": 89,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "forAllFiles",
    "memberof": "src/for-all-files.js",
    "longname": "src/for-all-files.js~forAllFiles",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/for-all-files.js",
    "importStyle": "{forAllFiles}",
    "description": "Invokes a method on all files in a directory recursively.",
    "lineNumber": 12,
    "params": [
      {
        "name": "rootDirectory",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 90,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "forAllFilesSync",
    "memberof": "src/for-all-files.js",
    "longname": "src/for-all-files.js~forAllFilesSync",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/for-all-files.js",
    "importStyle": "{forAllFilesSync}",
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [
      {
        "name": "rootDirectory",
        "types": [
          "*"
        ]
      },
      {
        "name": "func",
        "types": [
          "*"
        ]
      },
      {
        "name": "args",
        "types": [
          "...*"
        ],
        "spread": true
      }
    ],
    "generator": false
  },
  {
    "__docId__": 91,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/index.js",
    "memberof": null,
    "longname": "src/index.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './babel-maybefill';\nimport _ from 'lodash';\n\nimport * as configParser from './config-parser';\n\nimport CompilerHost from './compiler-host';\nimport FileChangedCache from './file-change-cache';\nimport CompileCache from './compile-cache';\n\nmodule.exports = _.assign({},\n  configParser,\n  { CompilerHost, FileChangedCache, CompileCache }\n);\n"
  },
  {
    "__docId__": 92,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/promise.js",
    "memberof": null,
    "longname": "src/promise.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import pify from 'pify';\n\n// NB: We do this so that every module doesn't have to run pify\n// on fs and zlib\n\n\n/**\n * @private\n */ \nexport const pfs = pify(require('fs'));\n\n/**\n * @private\n */ \n export const pzlib = pify(require('zlib'));\n"
  },
  {
    "__docId__": 93,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "pfs",
    "memberof": "src/promise.js",
    "longname": "src/promise.js~pfs",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/promise.js",
    "importStyle": "{pfs}",
    "description": null,
    "lineNumber": 10,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "pzlib",
    "memberof": "src/promise.js",
    "longname": "src/promise.js~pzlib",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/promise.js",
    "importStyle": "{pzlib}",
    "description": null,
    "lineNumber": 15,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 95,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/protocol-hook.js",
    "memberof": null,
    "longname": "src/protocol-hook.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './babel-maybefill';\nimport url from 'url';\nimport fs from 'fs';\nimport mime from 'mime-types';\n\nimport CompilerHost from './compiler-host';\n\nconst magicWords = \"__magic__file__to__help__electron__compile.js\";\nconst magicGlobalForRootCacheDir = '__electron_compile_root_cache_dir';\nconst magicGlobalForAppRootDir = '__electron_compile_app_root_dir';\n\nconst d = require('debug')('electron-compile:protocol-hook');\n\nlet protocol = null;\n\n/**\n * Adds our script header to the top of all HTML files\n *  \n * @private\n */ \nexport function rigHtmlDocumentToInitializeElectronCompile(doc) {\n  let lines = doc.split(\"\\n\");\n  let replacement = `<head><script src=\"${magicWords}\"></script>`;\n  let replacedHead = false;\n\n  for (let i=0; i < lines.length; i++) {\n    if (!lines[i].match(/<head>/i)) continue;\n\n    lines[i] = (lines[i]).replace(/<head>/i, replacement);\n    replacedHead = true;\n    break;\n  }\n\n  if (!replacedHead) {\n    replacement = `<html$1><head><script src=\"${magicWords}\"></script></head>`;\n    for (let i=0; i < lines.length; i++) {\n      if (!lines[i].match(/<html/i)) continue;\n\n      lines[i] = (lines[i]).replace(/<html([^>]+)>/i, replacement);\n      break;\n    }\n  }\n\n  return lines.join(\"\\n\");\n}\n\nfunction requestFileJob(filePath, finish) {\n  fs.readFile(filePath, (err, buf) => {\n    if (err) { \n      if (err.errno === 34) {\n        finish(-6); // net::ERR_FILE_NOT_FOUND\n        return;\n      } else {\n        finish(-2); // net::FAILED\n        return;\n      }\n    }\n    \n    finish({\n      data: buf,\n      mimeType: mime.lookup(filePath) || 'text/plain'\n    });\n  });\n}\n\nlet rendererInitialized = false;\n\n/**\n * Called by our rigged script file at the top of every HTML file to set up\n * the same compilers as the browser process that created us\n *  \n * @private\n */ \nexport function initializeRendererProcess(readOnlyMode) {\n  if (rendererInitialized) return;\n  \n  // NB: If we don't do this, we'll get a renderer crash if you enable debug\n  require('debug/browser');\n  \n  let rootCacheDir = require('remote').getGlobal(magicGlobalForRootCacheDir);\n  let appRoot = require('remote').getGlobal(magicGlobalForAppRootDir);\n  let compilerHost = null;\n  \n  // NB: This has to be synchronous because we need to block HTML parsing\n  // until we're set up\n  if (readOnlyMode) {\n    d(`Setting up electron-compile in precompiled mode with cache dir: ${rootCacheDir}`);\n    compilerHost = CompilerHost.createReadonlyFromConfigurationSync(rootCacheDir, appRoot);\n  } else {\n    d(`Setting up electron-compile in development mode with cache dir: ${rootCacheDir}`);\n    const { createCompilers } = require('./config-parser');\n    const compilersByMimeType = createCompilers();\n    \n    compilerHost = CompilerHost.createFromConfigurationSync(rootCacheDir, appRoot, compilersByMimeType);\n  }\n  \n  require('./x-require');\n  require('./require-hook').default(compilerHost);\n  rendererInitialized = true;\n}\n\n\n/**\n * Initializes the protocol hook on file: that allows us to intercept files \n * loaded by Chromium and rewrite them. This method along with \n * {@link registerRequireExtension} are the top-level methods that electron-compile\n * actually uses to intercept code that Electron loads.\n *  \n * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.\n */ \nexport function initializeProtocolHook(compilerHost) {\n  protocol = protocol || require('protocol');\n  \n  global[magicGlobalForRootCacheDir] = compilerHost.rootCacheDir;\n  global[magicGlobalForAppRootDir] = compilerHost.appRoot;\n  \n  const electronCompileSetupCode = `if (window.require) require('electron-compile/lib/protocol-hook').initializeRendererProcess(${compilerHost.readOnlyMode});`;\n\n  protocol.interceptBufferProtocol('file', async function(request, finish) {\n    let uri = url.parse(request.url);\n\n    d(`Intercepting url ${request.url}`);\n    if (request.url.indexOf(magicWords) > -1) {\n      finish({\n        mimeType: 'application/javascript',\n        data: new Buffer(electronCompileSetupCode, 'utf8')\n      });\n      \n      return;\n    }\n\n    // This is a protocol-relative URL that has gone pear-shaped in Electron,\n    // let's rewrite it\n    if (uri.host && uri.host.length > 1) {\n      //let newUri = request.url.replace(/^file:/, \"https:\");\n      // TODO: Jump off this bridge later\n      d(`TODO: Found bogus protocol-relative URL, can't fix it up!!`);\n      finish(-2);\n    }\n\n    let filePath = decodeURIComponent(uri.pathname);\n\n    // NB: pathname has a leading '/' on Win32 for some reason\n    if (process.platform === 'win32') {\n      filePath = filePath.slice(1);\n    }\n\n    // NB: Special-case files coming from atom.asar or node_modules\n    if (filePath.match(/[\\/\\\\]atom.asar/) || filePath.match(/[\\/\\\\]node_modules/)) {\n      requestFileJob(filePath, finish);\n      return;\n    }\n    \n    try {\n      let result = await compilerHost.compile(filePath);\n      \n      if (filePath.match(/\\.html?$/i)) {\n        result.code = rigHtmlDocumentToInitializeElectronCompile(result.code);\n      }\n      \n      if (result.binaryData || result.code instanceof Buffer) {\n        finish({ data: result.binaryData || result.code, mimeType: result.mimeType });\n        return;\n      } else {\n        finish({ data: new Buffer(result.code), mimeType: result.mimeType });\n        return;\n      }\n    } catch (e) {\n      let err = `Failed to compile ${filePath}: ${e.message}\\n${e.stack}`;\n      d(err);\n      \n      if (e.errno === 34 /*ENOENT*/) {\n        finish(-6); // net::ERR_FILE_NOT_FOUND\n        return;\n      }\n\n      finish({ mimeType: 'text/plain', data: new Buffer(err) });\n      return;\n    }\n  });\n}\n"
  },
  {
    "__docId__": 96,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "magicWords",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~magicWords",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "magicGlobalForRootCacheDir",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~magicGlobalForRootCacheDir",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 98,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "magicGlobalForAppRootDir",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~magicGlobalForAppRootDir",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "d",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~d",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "protocol",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~protocol",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 14,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 101,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "rigHtmlDocumentToInitializeElectronCompile",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~rigHtmlDocumentToInitializeElectronCompile",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": "{rigHtmlDocumentToInitializeElectronCompile}",
    "description": "Adds our script header to the top of all HTML files\n ",
    "lineNumber": 21,
    "params": [
      {
        "name": "doc",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 102,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "requestFileJob",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~requestFileJob",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 47,
    "undocument": true,
    "params": [
      {
        "name": "filePath",
        "types": [
          "*"
        ]
      },
      {
        "name": "finish",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 103,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "rendererInitialized",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~rendererInitialized",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "initializeRendererProcess",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~initializeRendererProcess",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": "{initializeRendererProcess}",
    "description": "Called by our rigged script file at the top of every HTML file to set up\nthe same compilers as the browser process that created us\n ",
    "lineNumber": 74,
    "params": [
      {
        "name": "readOnlyMode",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 105,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "initializeProtocolHook",
    "memberof": "src/protocol-hook.js",
    "longname": "src/protocol-hook.js~initializeProtocolHook",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/protocol-hook.js",
    "importStyle": "{initializeProtocolHook}",
    "description": "Initializes the protocol hook on file: that allows us to intercept files \nloaded by Chromium and rewrite them. This method along with \n{@link registerRequireExtension} are the top-level methods that electron-compile\nactually uses to intercept code that Electron loads.\n ",
    "lineNumber": 111,
    "params": [
      {
        "nullable": null,
        "types": [
          "CompilerHost"
        ],
        "spread": false,
        "optional": false,
        "name": "compilerHost",
        "description": "The compiler host to use for compilation."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 106,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/read-only-compiler.js",
    "memberof": null,
    "longname": "src/read-only-compiler.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\n\n\n/**\n * ReadOnlyCompiler is a compiler which allows the host to inject all of the compiler\n * metadata information so that {@link CompileCache} et al are able to recreate the\n * hash without having two separate code paths.\n */ \nexport default class ReadOnlyCompiler {\n  /**  \n   * Creates a ReadOnlyCompiler instance\n   *    \n   * @private\n   */   \n  constructor(name, compilerVersion, compilerOptions, inputMimeTypes) {\n    _.assign(this, { name, compilerVersion, compilerOptions, inputMimeTypes });\n  }\n  \n  async shouldCompileFile() { return true; }\n  async determineDependentFiles() { return []; }\n\n  async compile() {\n    throw new Error(\"Read-only compilers can't compile\");\n  }\n\n  shouldCompileFileSync() { return true; }\n  determineDependentFilesSync() { return []; }\n\n  compileSync() {\n    throw new Error(\"Read-only compilers can't compile\");\n  }\n\n  getCompilerVersion() {\n    return this.compilerVersion;\n  }\n}\n"
  },
  {
    "__docId__": 107,
    "kind": "class",
    "static": true,
    "variation": null,
    "name": "ReadOnlyCompiler",
    "memberof": "src/read-only-compiler.js",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/read-only-compiler.js",
    "importStyle": "ReadOnlyCompiler",
    "description": "ReadOnlyCompiler is a compiler which allows the host to inject all of the compiler\nmetadata information so that {@link CompileCache} et al are able to recreate the\nhash without having two separate code paths.",
    "lineNumber": 9,
    "interface": false
  },
  {
    "__docId__": 108,
    "kind": "constructor",
    "static": false,
    "variation": null,
    "name": "constructor",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#constructor",
    "access": "private",
    "description": " \nCreates a ReadOnlyCompiler instance\n   ",
    "lineNumber": 15,
    "params": [
      {
        "name": "name",
        "types": [
          "*"
        ]
      },
      {
        "name": "compilerVersion",
        "types": [
          "*"
        ]
      },
      {
        "name": "compilerOptions",
        "types": [
          "*"
        ]
      },
      {
        "name": "inputMimeTypes",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 109,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "shouldCompileFile",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#shouldCompileFile",
    "access": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 110,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "determineDependentFiles",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#determineDependentFiles",
    "access": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 111,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compile",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#compile",
    "access": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 112,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "shouldCompileFileSync",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#shouldCompileFileSync",
    "access": null,
    "description": null,
    "lineNumber": 26,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 113,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "determineDependentFilesSync",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#determineDependentFilesSync",
    "access": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 114,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "compileSync",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#compileSync",
    "access": null,
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 115,
    "kind": "method",
    "static": false,
    "variation": null,
    "name": "getCompilerVersion",
    "memberof": "src/read-only-compiler.js~ReadOnlyCompiler",
    "longname": "src/read-only-compiler.js~ReadOnlyCompiler#getCompilerVersion",
    "access": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    },
    "generator": false
  },
  {
    "__docId__": 116,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/require-hook.js",
    "memberof": null,
    "longname": "src/require-hook.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\nimport mimeTypes from 'mime-types';\n\n/**\n * Initializes the node.js hook that allows us to intercept files loaded by \n * node.js and rewrite them. This method along with {@link initializeProtocolHook} \n * are the top-level methods that electron-compile actually uses to intercept \n * code that Electron loads.\n *  \n * @param  {CompilerHost} compilerHost  The compiler host to use for compilation.\n */ \nexport default function registerRequireExtension(compilerHost) {\n  _.each(Object.keys(compilerHost.compilersByMimeType), (mimeType) => {\n    let ext = mimeTypes.extension(mimeType);\n    \n    require.extensions[`.${ext}`] = (module, filename) => {\n      let {code} = compilerHost.compileSync(filename);\n      module._compile(code, filename);\n    };\n  });\n}\n"
  },
  {
    "__docId__": 117,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "registerRequireExtension",
    "memberof": "src/require-hook.js",
    "longname": "src/require-hook.js~registerRequireExtension",
    "access": null,
    "export": true,
    "importPath": "electron-compile/src/require-hook.js",
    "importStyle": "registerRequireExtension",
    "description": "Initializes the node.js hook that allows us to intercept files loaded by \nnode.js and rewrite them. This method along with {@link initializeProtocolHook} \nare the top-level methods that electron-compile actually uses to intercept \ncode that Electron loads.\n ",
    "lineNumber": 12,
    "params": [
      {
        "nullable": null,
        "types": [
          "CompilerHost"
        ],
        "spread": false,
        "optional": false,
        "name": "compilerHost",
        "description": "The compiler host to use for compilation."
      }
    ],
    "generator": false
  },
  {
    "__docId__": 118,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/rig-mime-types.js",
    "memberof": null,
    "longname": "src/rig-mime-types.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\nimport mimeTypes from 'mime-types';\n\nconst typesToRig = {\n  'text/typescript': 'ts',\n  'text/jade': 'jade'\n};\n\n\n/**\n * Adds MIME types for types not in the mime-types package\n *  \n * @private\n */ \nexport function init() {\n  _.each(Object.keys(typesToRig), (type) => {\n    let ext = typesToRig[type];\n\n    mimeTypes.types[ext] = type;\n    mimeTypes.extensions[type] = _.clone([ext], true);\n  });\n}\n"
  },
  {
    "__docId__": 119,
    "kind": "variable",
    "static": true,
    "variation": null,
    "name": "typesToRig",
    "memberof": "src/rig-mime-types.js",
    "longname": "src/rig-mime-types.js~typesToRig",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/rig-mime-types.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 120,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "init",
    "memberof": "src/rig-mime-types.js",
    "longname": "src/rig-mime-types.js~init",
    "access": "private",
    "export": true,
    "importPath": "electron-compile/src/rig-mime-types.js",
    "importStyle": "{init}",
    "description": "Adds MIME types for types not in the mime-types package\n ",
    "lineNumber": 15,
    "params": [],
    "generator": false
  },
  {
    "__docId__": 121,
    "kind": "file",
    "static": true,
    "variation": null,
    "name": "src/x-require.js",
    "memberof": null,
    "longname": "src/x-require.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\nimport url from 'url';\n\nfunction requireModule(href) {\n  let filePath = href;\n  \n  if (filePath.match(/^file:/i)) {\n    let theUrl = url.parse(filePath);\n    filePath = decodeURIComponent(theUrl.pathname);\n\n    if (process.platform === 'win32') {\n      filePath = filePath.slice(1);\n    }\n  }\n  \n  // NB: We don't do any path canonicalization here because we rely on\n  // InlineHtmlCompiler to have already converted any relative paths that\n  // were used with x-require into absolute paths.\n  require(filePath);\n}\n\n/**\n * @private\n */ \nexport default (() => {\n  if (process.type !== 'renderer' || !window || !window.document) return null;\n  \n  let proto = _.extend(Object.create(HTMLElement.prototype), {\n    createdCallback: function() {\n      let href = this.getAttribute('src');\n      if (href && href.length > 0) {\n        requireModule(href);\n      }\n    }, \n    attributeChangedCallback: function(attrName, oldVal, newVal) {\n      if (attrName !== 'src') return;\n      requireModule(newVal);\n    }\n  });\n\n  return document.registerElement('x-require', { prototype: proto });\n})();\n"
  },
  {
    "__docId__": 122,
    "kind": "function",
    "static": true,
    "variation": null,
    "name": "requireModule",
    "memberof": "src/x-require.js",
    "longname": "src/x-require.js~requireModule",
    "access": null,
    "export": false,
    "importPath": "electron-compile/src/x-require.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "params": [
      {
        "name": "href",
        "types": [
          "*"
        ]
      }
    ],
    "generator": false
  },
  {
    "__docId__": 124,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Infinity",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 125,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~NaN",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 126,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~undefined",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 127,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~null",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 128,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 129,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~object",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 130,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 131,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~function",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 132,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 133,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~boolean",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 134,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Symbol",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 135,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Error",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 136,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~EvalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 137,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~InternalError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 138,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RangeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 139,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ReferenceError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 140,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~SyntaxError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 141,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~TypeError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 142,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~URIError",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 143,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 144,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~number",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 145,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Date",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 146,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~String",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 147,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~string",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 148,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~RegExp",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 149,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 150,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 151,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 152,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint8ClampedArray",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 153,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 154,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint16Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 155,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Int32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 156,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Uint32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 157,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float32Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 158,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Float64Array",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 159,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Map",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 160,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Set",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 161,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakMap",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 162,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~WeakSet",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 163,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~ArrayBuffer",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 164,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~DataView",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 165,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~JSON",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 166,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Promise",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 167,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Generator",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 168,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~GeneratorFunction",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 169,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Reflect",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 170,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "BuiltinExternal/ECMAScriptExternal.js",
    "longname": "BuiltinExternal/ECMAScriptExternal.js~Proxy",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 172,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "CanvasRenderingContext2D",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~CanvasRenderingContext2D",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 173,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "DocumentFragment",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~DocumentFragment",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 174,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Element",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Element",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Element",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 175,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Event",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Event",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Event",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 176,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "Node",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/Node",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~Node",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 177,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "NodeList",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/API/NodeList",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~NodeList",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 178,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "XMLHttpRequest",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~XMLHttpRequest",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 179,
    "kind": "external",
    "static": true,
    "variation": null,
    "name": "AudioContext",
    "externalLink": "https://developer.mozilla.org/en/docs/Web/API/AudioContext",
    "memberof": "BuiltinExternal/WebAPIExternal.js",
    "longname": "BuiltinExternal/WebAPIExternal.js~AudioContext",
    "access": null,
    "description": null,
    "builtinExternal": true
  },
  {
    "__docId__": 180,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/compile-cache.js",
    "memberof": null,
    "longname": "test/compile-cache.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './support.js';\n\nimport fs from 'fs';\nimport path from 'path';\nimport rimraf from 'rimraf';\nimport mkdirp from 'mkdirp';\nimport FileChangeCache from '../lib/file-change-cache';\nimport CompileCache from '../lib/compile-cache';\nimport pify from 'pify';\n\nconst pfs = pify(fs);\n\nlet testCount=0;\n\ndescribe('The compile cache', function() {\n  beforeEach(function() {\n    this.appRootDir = path.join(__dirname, '..');\n    this.fileChangeCache = new FileChangeCache(this.appRootDir);\n    \n    this.tempCacheDir = path.join(__dirname, `__compile_cache_${testCount++}`);\n    mkdirp.sync(this.tempCacheDir);\n    this.fixture = new CompileCache(this.tempCacheDir, this.fileChangeCache);\n  });\n  \n  afterEach(function() {\n    rimraf.sync(this.tempCacheDir);\n  });\n  \n  it('Should only call compile once for the same file', async function() {\n    let inputFile = path.resolve(__dirname, '..', 'src', 'compile-cache.js');\n    let callCount = 0;\n    \n    let fetcher = async function(filePath, hashInfo) {\n      callCount++;\n      \n      let code = hashInfo.sourceCode || await pfs.readFile(filePath, 'utf8');\n      let mimeType = 'application/javascript';\n      return { code, mimeType };\n    };\n    \n    let result = await this.fixture.getOrFetch(inputFile, fetcher);\n    \n    expect(result.mimeType).to.equal('application/javascript');\n    expect(result.code.length > 10).to.be.ok;\n    expect(callCount).to.equal(1);\n    \n    result = await this.fixture.getOrFetch(inputFile, fetcher);\n      \n    expect(result.mimeType).to.equal('application/javascript');\n    expect(result.code.length > 10).to.be.ok;\n    expect(callCount).to.equal(1);\n    \n    this.fixture = new CompileCache(this.tempCacheDir, this.fileChangeCache);\n        \n    result = await this.fixture.getOrFetch(inputFile, fetcher);\n      \n    expect(result.mimeType).to.equal('application/javascript');\n    expect(result.code.length > 10).to.be.ok;\n    expect(callCount).to.equal(1);\n  });\n    \n  it('Should roundtrip binary files', async function() {\n    let inputFile = path.resolve(__dirname, '..', 'test', 'fixtures', 'binaryfile.zip');\n    let hashInfo = await this.fileChangeCache.getHashForPath(inputFile);\n    \n    await this.fixture.save(hashInfo, hashInfo.binaryData, 'application/zip');\n    \n    let fetcher = async function() {\n      throw new Error(\"No\");\n    };\n    \n    let result = await this.fixture.getOrFetch(inputFile, fetcher);\n    expect(result.mimeType).to.equal('application/zip');\n    expect(result.binaryData.length).to.equal(hashInfo.binaryData.length);\n  \n    this.fixture = new CompileCache(this.tempCacheDir, this.fileChangeCache);\n        \n    result = await this.fixture.getOrFetch(inputFile, fetcher);\n    expect(result.mimeType).to.equal('application/zip');\n    expect(result.binaryData.length).to.equal(hashInfo.binaryData.length);  \n  });\n    \n  it('Should roundtrip binary files synchronously', function() {\n    let inputFile = path.resolve(__dirname, '..', 'test', 'fixtures', 'binaryfile.zip');\n    let hashInfo = this.fileChangeCache.getHashForPathSync(inputFile);\n    \n    this.fixture.saveSync(hashInfo, hashInfo.binaryData, 'application/zip');\n    \n    let fetcher = function() {\n      throw new Error(\"No\");\n    };\n    \n    let result = this.fixture.getOrFetchSync(inputFile, fetcher);\n    expect(result.mimeType).to.equal('application/zip');\n    expect(result.binaryData.length).to.equal(hashInfo.binaryData.length);\n  \n    this.fixture = new CompileCache(this.tempCacheDir, this.fileChangeCache);\n        \n    result = this.fixture.getOrFetchSync(inputFile, fetcher);\n    expect(result.mimeType).to.equal('application/zip');\n    expect(result.binaryData.length).to.equal(hashInfo.binaryData.length);  \n  });\n  \n  it('Should only call compile once for the same file synchronously', function() {\n    let inputFile = path.resolve(__dirname, '..', 'src', 'compile-cache.js');\n    let callCount = 0;\n    \n    let fetcher = function(filePath, hashInfo) {\n      callCount++;\n      \n      let code = hashInfo.sourceCode || fs.readFileSync(filePath, 'utf8');\n      let mimeType = 'application/javascript';\n      \n      return { code, mimeType };\n    };\n    \n    let result = this.fixture.getOrFetchSync(inputFile, fetcher);\n    \n    expect(result.mimeType).to.equal('application/javascript');\n    expect(result.code.length > 10).to.be.ok;\n    expect(callCount).to.equal(1);\n    \n    result = this.fixture.getOrFetchSync(inputFile, fetcher);\n      \n    expect(result.mimeType).to.equal('application/javascript');\n    expect(result.code.length > 10).to.be.ok;\n    expect(callCount).to.equal(1);\n    \n    this.fixture = new CompileCache(this.tempCacheDir, this.fileChangeCache);\n        \n    result = this.fixture.getOrFetchSync(inputFile, fetcher);\n      \n    expect(result.mimeType).to.equal('application/javascript');\n    expect(result.code.length > 10).to.be.ok;\n    expect(callCount).to.equal(1);\n  });\n\n  it('Shouldnt cache compile failures', async function() {\n    let inputFile = path.resolve(__dirname, '..', 'lib', 'compile-cache.js');\n    let callCount = 0;\n    let weBlewUpCount = 0;\n    \n    let fetcher = async function() {\n      callCount++;\n      throw new Error(\"Lolz\");\n    };\n    \n    try {\n      await this.fixture.getOrFetch(inputFile, fetcher);    \n    } catch (e) {\n      weBlewUpCount++;\n    }\n\n    expect(callCount).to.equal(1);\n    expect(weBlewUpCount).to.equal(1);\n\n    try {\n      await this.fixture.getOrFetch(inputFile, fetcher);    \n    } catch (e) {\n      weBlewUpCount++;\n    }\n    \n    expect(callCount).to.equal(2);\n    expect(weBlewUpCount).to.equal(2);\n  });\n});\n"
  },
  {
    "__docId__": 181,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe0",
    "testId": 0,
    "memberof": "test/compile-cache.js",
    "testDepth": 0,
    "longname": "test/compile-cache.js~describe0",
    "access": null,
    "description": "The compile cache",
    "lineNumber": 15
  },
  {
    "__docId__": 182,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it1",
    "testId": 1,
    "memberof": "test/compile-cache.js~describe0",
    "testDepth": 1,
    "longname": "test/compile-cache.js~describe0.it1",
    "access": null,
    "description": "Should only call compile once for the same file",
    "lineNumber": 29
  },
  {
    "__docId__": 183,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it2",
    "testId": 2,
    "memberof": "test/compile-cache.js~describe0",
    "testDepth": 1,
    "longname": "test/compile-cache.js~describe0.it2",
    "access": null,
    "description": "Should roundtrip binary files",
    "lineNumber": 62
  },
  {
    "__docId__": 184,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it3",
    "testId": 3,
    "memberof": "test/compile-cache.js~describe0",
    "testDepth": 1,
    "longname": "test/compile-cache.js~describe0.it3",
    "access": null,
    "description": "Should roundtrip binary files synchronously",
    "lineNumber": 83
  },
  {
    "__docId__": 185,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it4",
    "testId": 4,
    "memberof": "test/compile-cache.js~describe0",
    "testDepth": 1,
    "longname": "test/compile-cache.js~describe0.it4",
    "access": null,
    "description": "Should only call compile once for the same file synchronously",
    "lineNumber": 104
  },
  {
    "__docId__": 186,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it5",
    "testId": 5,
    "memberof": "test/compile-cache.js~describe0",
    "testDepth": 1,
    "longname": "test/compile-cache.js~describe0.it5",
    "access": null,
    "description": "Shouldnt cache compile failures",
    "lineNumber": 138
  },
  {
    "__docId__": 187,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/compiler-host.js",
    "memberof": null,
    "longname": "test/compiler-host.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './support.js';\n\nimport _ from 'lodash';\nimport path from 'path';\nimport fs from 'fs';\nimport rimraf from 'rimraf';\nimport mkdirp from 'mkdirp';\nimport mimeTypes from 'mime-types';\nimport FileChangeCache from '../lib/file-change-cache';\nimport CompilerHost from '../lib/compiler-host';\n\nconst d = require('debug')('test:compiler-host');\n\nlet testCount=0;\n\ndescribe('All available compilers', function() {\n  it('should have a MIME type in mime-types', function() {\n    _.each(Object.keys(global.compilersByMimeType), (type) => {\n      d(`Extension for ${type} is ${mimeTypes.extension(type)}`);\n      expect(mimeTypes.extension(type)).to.be.ok;\n    });\n  });\n});\n\ndescribe('The compiler host', function() {\n  this.timeout(15*1000);\n\n  beforeEach(function() {\n    this.appRootDir = path.join(__dirname, '..');\n    this.fileChangeCache = new FileChangeCache(this.appRootDir);\n        \n    this.tempCacheDir = path.join(__dirname, `__compile_cache_${testCount++}`);\n    mkdirp.sync(this.tempCacheDir);\n    \n    this.compilersByMimeType = _.reduce(Object.keys(global.compilersByMimeType), (acc, type) => {\n      let Klass = global.compilersByMimeType[type];\n      acc[type] = new Klass();\n      return acc;\n    }, {});\n    \n    let InlineHtmlCompiler = Object.getPrototypeOf(this.compilersByMimeType['text/html']).constructor;\n    this.compilersByMimeType['text/html'] = InlineHtmlCompiler.createFromCompilers(this.compilersByMimeType);\n    \n    this.fixture = new CompilerHost(this.tempCacheDir, this.compilersByMimeType, this.fileChangeCache, false);\n  });\n  \n  afterEach(function() {\n    rimraf.sync(this.tempCacheDir);\n  });\n\n  it('should compile basic HTML and not blow up', function() {\n    let input = '<html><style type=\"text/less\">body { font-family: \"lol\"; }</style></html>';\n    let inFile = path.join(this.tempCacheDir, 'input.html');\n    fs.writeFileSync(inFile, input);\n    \n    let result = this.fixture.compileSync(inFile);\n\n    expect(result.mimeType).to.equal('text/html');\n    expect(result.code.length > input.length).to.be.ok;\n  });\n\n  it('Should compile everything in the fixtures directory', async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures');\n\n    await this.fixture.compileAll(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n  });\n  \n  it('Should compile everything in the fixtures directory sync', function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures');\n\n    this.fixture.compileAllSync(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n  });\n  \n  it('Should read files from cache once we compile them', async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures');\n\n    await this.fixture.compileAll(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n    \n    this.fixture = new CompilerHost(this.tempCacheDir, this.compilersByMimeType, this.fileChangeCache, true);\n    this.fixture.compileUncached = () => Promise.reject(new Error(\"Fail!\"));\n\n    await this.fixture.compileAll(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n  });\n  \n  it('Should read files from cache once we compile them synchronously', function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures');\n\n    this.fixture.compileAllSync(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n    \n    this.fixture = new CompilerHost(this.tempCacheDir, this.compilersByMimeType, this.fileChangeCache, true);\n    this.fixture.compileUncached = () => { throw new Error(\"Fail!\"); };\n\n    this.fixture.compileAllSync(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n  });\n  \n  it('Should read files from serialized compiler information', async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures');\n\n    d(\"Attempting to run initial compile\");\n    await this.fixture.compileAll(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n    \n    d(\"Saving configuration\");\n    await this.fixture.saveConfiguration();\n    \n    d(\"Recreating from said configuration\");\n    this.fixture = await CompilerHost.createReadonlyFromConfiguration(this.tempCacheDir, this.appRootDir);\n    this.fixture.compileUncached = () => Promise.reject(new Error(\"Fail!\"));\n\n    d(\"Recompiling everything from cached data\");\n    await this.fixture.compileAll(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n  });\n  \n  it('Should read files from serialized compiler information synchronously', function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures');\n\n    d(\"Attempting to run initial compile\");\n    this.fixture.compileAllSync(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n    \n    d(\"Saving configuration\");\n    this.fixture.saveConfigurationSync();\n    \n    d(\"Recreating from said configuration\");\n    this.fixture = CompilerHost.createReadonlyFromConfigurationSync(this.tempCacheDir, this.appRootDir);\n    this.fixture.compileUncached = () => Promise.reject(new Error(\"Fail!\"));\n\n    d(\"Recompiling everything from cached data\");\n    this.fixture.compileAllSync(input, (filePath) => {\n      if (filePath.match(/invalid/)) return false;\n      if (filePath.match(/binaryfile/)) return false;\n      if (filePath.match(/minified/)) return false;\n      if (filePath.match(/source_map/)) return false;\n      if (filePath.match(/babelrc/)) return false;\n      if (filePath.match(/compilerc/)) return false;\n      \n      return true;\n    });\n  });\n});\n"
  },
  {
    "__docId__": 188,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe6",
    "testId": 6,
    "memberof": "test/compiler-host.js",
    "testDepth": 0,
    "longname": "test/compiler-host.js~describe6",
    "access": null,
    "description": "All available compilers",
    "lineNumber": 16
  },
  {
    "__docId__": 189,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it7",
    "testId": 7,
    "memberof": "test/compiler-host.js~describe6",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe6.it7",
    "access": null,
    "description": "should have a MIME type in mime-types",
    "lineNumber": 17
  },
  {
    "__docId__": 190,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe8",
    "testId": 8,
    "memberof": "test/compiler-host.js",
    "testDepth": 0,
    "longname": "test/compiler-host.js~describe8",
    "access": null,
    "description": "The compiler host",
    "lineNumber": 25
  },
  {
    "__docId__": 191,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it9",
    "testId": 9,
    "memberof": "test/compiler-host.js~describe8",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe8.it9",
    "access": null,
    "description": "should compile basic HTML and not blow up",
    "lineNumber": 51
  },
  {
    "__docId__": 192,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it10",
    "testId": 10,
    "memberof": "test/compiler-host.js~describe8",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe8.it10",
    "access": null,
    "description": "Should compile everything in the fixtures directory",
    "lineNumber": 62
  },
  {
    "__docId__": 193,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it11",
    "testId": 11,
    "memberof": "test/compiler-host.js~describe8",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe8.it11",
    "access": null,
    "description": "Should compile everything in the fixtures directory sync",
    "lineNumber": 77
  },
  {
    "__docId__": 194,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it12",
    "testId": 12,
    "memberof": "test/compiler-host.js~describe8",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe8.it12",
    "access": null,
    "description": "Should read files from cache once we compile them",
    "lineNumber": 92
  },
  {
    "__docId__": 195,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it13",
    "testId": 13,
    "memberof": "test/compiler-host.js~describe8",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe8.it13",
    "access": null,
    "description": "Should read files from cache once we compile them synchronously",
    "lineNumber": 121
  },
  {
    "__docId__": 196,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it14",
    "testId": 14,
    "memberof": "test/compiler-host.js~describe8",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe8.it14",
    "access": null,
    "description": "Should read files from serialized compiler information",
    "lineNumber": 150
  },
  {
    "__docId__": 197,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it15",
    "testId": 15,
    "memberof": "test/compiler-host.js~describe8",
    "testDepth": 1,
    "longname": "test/compiler-host.js~describe8.it15",
    "access": null,
    "description": "Should read files from serialized compiler information synchronously",
    "lineNumber": 185
  },
  {
    "__docId__": 198,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/compiler-valid-invalid.js",
    "memberof": null,
    "longname": "test/compiler-valid-invalid.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './support';\n\nimport pify from 'pify';\nimport fs from 'fs';\nimport path from 'path';\nimport _ from 'lodash';\nimport mimeTypes from 'mime-types';\n\nconst pfs = pify(fs);\n\nlet allFixtureFiles = _.filter(\n  fs.readdirSync(path.join(__dirname, '..', 'test', 'fixtures')),\n  (x) => x.match(/invalid\\./i));\n  \nlet mimeTypesToTest = _.reduce(allFixtureFiles, (acc,x) => {\n  if (global.compilersByMimeType[mimeTypes.lookup(x) || '__nope__']) {\n    acc.push(mimeTypes.lookup(x));\n  }\n  \n  return acc;\n}, []);\n\nconst expectedMimeTypeSpecialCases = {\n  'text/less': 'text/css',\n  'text/jade': 'text/html'\n};\n\nfor (let mimeType of mimeTypesToTest) {\n  let klass = global.compilersByMimeType[mimeType];\n  \n  describe(`The ${klass.name} class for ${mimeType}`, function() {\n    beforeEach(function() {\n      this.fixture = new klass();\n    });\n\n    it(`should compile the valid ${mimeType} file`, async function() {\n      let ext = mimeTypes.extension(mimeType);\n      let input = path.join(__dirname, '..', 'test', 'fixtures', `valid.${ext}`);\n\n      let ctx = {};\n      let shouldCompile = await this.fixture.shouldCompileFile(input, ctx);\n      expect(shouldCompile).to.be.ok;\n\n      let source = await pfs.readFile(input, 'utf8');\n      let dependentFiles = await this.fixture.determineDependentFiles(source, input, ctx);\n      expect(dependentFiles.length).to.equal(0);\n\n      let result = await this.fixture.compile(source, input, ctx);\n      let expectedMimeType = expectedMimeTypeSpecialCases[mimeType] || 'application/javascript';\n      \n      expect(result.mimeType).to.equal(expectedMimeType);\n\n      // NB: Jade doesn't do source maps\n      if (mimeType !== 'text/jade') {\n        let lines = result.code.split('\\n');\n        expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).to.be.ok;\n      }\n    });\n\n    it(`should fail the invalid ${mimeType} file`, async function() {\n      let ext = mimeTypes.extension(mimeType);\n      let input = path.join(__dirname, '..', 'test', 'fixtures', `invalid.${ext}`);\n\n      let ctx = {};\n      let shouldCompile = await this.fixture.shouldCompileFile(input, ctx);\n      expect(shouldCompile).to.be.ok;\n\n      let source = await pfs.readFile(input, 'utf8');\n      let dependentFiles = await this.fixture.determineDependentFiles(source, input, ctx);\n      expect(dependentFiles.length).to.equal(0);\n\n      let result = this.fixture.compile(source, input, ctx);\n      expect(result).to.eventually.throw();\n    });\n  });\n}\n"
  },
  {
    "__docId__": 199,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe16",
    "testId": 16,
    "memberof": "test/compiler-valid-invalid.js",
    "testDepth": 0,
    "longname": "test/compiler-valid-invalid.js~describe16",
    "access": null,
    "lineNumber": 31
  },
  {
    "__docId__": 200,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it17",
    "testId": 17,
    "memberof": "test/compiler-valid-invalid.js~describe16",
    "testDepth": 1,
    "longname": "test/compiler-valid-invalid.js~describe16.it17",
    "access": null,
    "lineNumber": 36
  },
  {
    "__docId__": 201,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it18",
    "testId": 18,
    "memberof": "test/compiler-valid-invalid.js~describe16",
    "testDepth": 1,
    "longname": "test/compiler-valid-invalid.js~describe16.it18",
    "access": null,
    "lineNumber": 60
  },
  {
    "__docId__": 202,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/config-parser.js",
    "memberof": null,
    "longname": "test/config-parser.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import _ from 'lodash';\nimport path from 'path';\nimport mkdirp from 'mkdirp';\nimport rimraf from 'rimraf';\n\nimport {\n  createCompilers, \n  createCompilerHostFromConfiguration, \n  createCompilerHostFromConfigFile,\n  createCompilerHostFromBabelRc\n} from '../lib/config-parser';\n\nconst d = require('debug')('test:config-parser');\n\nlet testCount = 0;\n\ndescribe('the configuration parser module', function() {\n  describe('the createCompilers method', function() {\n    it('should return compilers', function() {\n      let result = createCompilers();\n      expect(Object.keys(result).length > 0).to.be.ok;\n    });\n\n    it('should definitely have these compilers', function() {\n      let result = createCompilers();\n\n      expect(result['application/javascript']).to.be.ok;\n      expect(result['text/less']).to.be.ok;\n    });\n  });\n  \n  describe('the createCompilerHostFromConfiguration method', function() {\n    beforeEach(function() {\n      this.tempCacheDir = path.join(__dirname, `__create_compiler_host_${testCount++}`);\n      mkdirp.sync(this.tempCacheDir);\n    });\n    \n    afterEach(function() {\n      rimraf.sync(this.tempCacheDir);\n    });\n      \n    it('respects suppressing source maps (scenario test)', async function() {\n      let fixtureDir = path.join(__dirname, '..', 'test', 'fixtures');\n      \n      let result = createCompilerHostFromConfiguration({\n        appRoot: fixtureDir,\n        rootCacheDir: this.tempCacheDir,\n        options: {\n          'application/javascript': {\n            \"presets\": [\"stage-0\", \"es2015\"],\n            \"sourceMaps\": false\n          }\n        }\n      });\n      \n      let compileInfo = await result.compile(path.join(fixtureDir, 'valid.js'));\n      d(JSON.stringify(compileInfo));\n      \n      expect(compileInfo.mimeType).to.equal('application/javascript');\n      \n      let lines = compileInfo.code.split('\\n');\n      expect(lines.length > 5).to.be.ok;\n      expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).not.to.be.ok;\n    });\n  });\n\n  describe('the createCompilerHostFromBabelRc method', function() {\n    beforeEach(function() {\n      this.tempCacheDir = path.join(__dirname, `__create_compiler_host_${testCount++}`);\n      mkdirp.sync(this.tempCacheDir);\n    });\n    \n    afterEach(function() {\n      rimraf.sync(this.tempCacheDir);\n      if ('BABEL_ENV' in process.env) {\n        delete process.env.ELECTRON_COMPILE_ENV;\n      }\n    });\n      \n    it('reads from an environment-free file', async function() {\n      let fixtureDir = path.join(__dirname, '..', 'test', 'fixtures');\n      \n      let result = await createCompilerHostFromBabelRc(path.join(fixtureDir, 'babelrc-noenv'));\n      \n      let compileInfo = await result.compile(path.join(fixtureDir, 'valid.js'));\n      d(JSON.stringify(compileInfo));\n      \n      expect(compileInfo.mimeType).to.equal('application/javascript');\n      \n      let lines = compileInfo.code.split('\\n');\n      expect(lines.length > 5).to.be.ok;\n      expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).to.be.ok;\n    });\n    \n    it('uses the development env when env is unset', async function() {\n      let fixtureDir = path.join(__dirname, '..', 'test', 'fixtures');\n      \n      let result = await createCompilerHostFromBabelRc(path.join(fixtureDir, 'babelrc-production'));\n      \n      let compileInfo = await result.compile(path.join(fixtureDir, 'valid.js'));\n      d(JSON.stringify(compileInfo));\n      \n      expect(compileInfo.mimeType).to.equal('application/javascript');\n      \n      let lines = compileInfo.code.split('\\n');\n      expect(lines.length > 5).to.be.ok;\n      expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).to.be.ok;\n    });\n    \n    it('uses the production env when env is set', async function() {\n      process.env.BABEL_ENV = 'production';\n      let fixtureDir = path.join(__dirname, '..', 'test', 'fixtures');\n      \n      let result = await createCompilerHostFromBabelRc(path.join(fixtureDir, 'babelrc-production'));\n      \n      let compileInfo = await result.compile(path.join(fixtureDir, 'valid.js'));\n      d(JSON.stringify(compileInfo));\n      \n      expect(compileInfo.mimeType).to.equal('application/javascript');\n      \n      let lines = compileInfo.code.split('\\n');\n      expect(lines.length > 5).to.be.ok;\n      expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).not.to.be.ok;\n    });  \n  });\n  \n  describe('the createCompilerHostFromConfigFile method', function() {\n    beforeEach(function() {\n      this.tempCacheDir = path.join(__dirname, `__create_compiler_host_${testCount++}`);\n      mkdirp.sync(this.tempCacheDir);\n    });\n    \n    afterEach(function() {\n      rimraf.sync(this.tempCacheDir);\n      if ('ELECTRON_COMPILE_ENV' in process.env) {\n        delete process.env.ELECTRON_COMPILE_ENV;\n      }\n    });\n      \n    it('reads from an environment-free file', async function() {\n      let fixtureDir = path.join(__dirname, '..', 'test', 'fixtures');\n      \n      let result = await createCompilerHostFromConfigFile(path.join(fixtureDir, 'compilerc-noenv'));\n      \n      let compileInfo = await result.compile(path.join(fixtureDir, 'valid.js'));\n      d(JSON.stringify(compileInfo));\n      \n      expect(compileInfo.mimeType).to.equal('application/javascript');\n      \n      let lines = compileInfo.code.split('\\n');\n      expect(lines.length > 5).to.be.ok;\n      expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).to.be.ok;\n    });\n    \n    it('uses the development env when env is unset', async function() {\n      let fixtureDir = path.join(__dirname, '..', 'test', 'fixtures');\n      \n      let result = await createCompilerHostFromConfigFile(path.join(fixtureDir, 'compilerc-production'));\n      \n      let compileInfo = await result.compile(path.join(fixtureDir, 'valid.js'));\n      d(JSON.stringify(compileInfo));\n      \n      expect(compileInfo.mimeType).to.equal('application/javascript');\n      \n      let lines = compileInfo.code.split('\\n');\n      expect(lines.length > 5).to.be.ok;\n      expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).to.be.ok;\n    });\n    \n    it('uses the production env when env is set', async function() {\n      process.env.ELECTRON_COMPILE_ENV = 'production';\n      let fixtureDir = path.join(__dirname, '..', 'test', 'fixtures');\n      \n      let result = await createCompilerHostFromConfigFile(path.join(fixtureDir, 'compilerc-production'));\n      \n      let compileInfo = await result.compile(path.join(fixtureDir, 'valid.js'));\n      d(JSON.stringify(compileInfo));\n      \n      expect(compileInfo.mimeType).to.equal('application/javascript');\n      \n      let lines = compileInfo.code.split('\\n');\n      expect(lines.length > 5).to.be.ok;\n      expect(_.any(lines, (x) => x.match(/sourceMappingURL=/))).not.to.be.ok;\n    });  \n  });\n});\n"
  },
  {
    "__docId__": 203,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe19",
    "testId": 19,
    "memberof": "test/config-parser.js",
    "testDepth": 0,
    "longname": "test/config-parser.js~describe19",
    "access": null,
    "description": "the configuration parser module",
    "lineNumber": 17
  },
  {
    "__docId__": 204,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe20",
    "testId": 20,
    "memberof": "test/config-parser.js~describe19",
    "testDepth": 1,
    "longname": "test/config-parser.js~describe19.describe20",
    "access": null,
    "description": "the createCompilers method",
    "lineNumber": 18
  },
  {
    "__docId__": 205,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it21",
    "testId": 21,
    "memberof": "test/config-parser.js~describe19.describe20",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe20.it21",
    "access": null,
    "description": "should return compilers",
    "lineNumber": 19
  },
  {
    "__docId__": 206,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it22",
    "testId": 22,
    "memberof": "test/config-parser.js~describe19.describe20",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe20.it22",
    "access": null,
    "description": "should definitely have these compilers",
    "lineNumber": 24
  },
  {
    "__docId__": 207,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe23",
    "testId": 23,
    "memberof": "test/config-parser.js~describe19",
    "testDepth": 1,
    "longname": "test/config-parser.js~describe19.describe23",
    "access": null,
    "description": "the createCompilerHostFromConfiguration method",
    "lineNumber": 32
  },
  {
    "__docId__": 208,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it24",
    "testId": 24,
    "memberof": "test/config-parser.js~describe19.describe23",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe23.it24",
    "access": null,
    "description": "respects suppressing source maps (scenario test)",
    "lineNumber": 42
  },
  {
    "__docId__": 209,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe25",
    "testId": 25,
    "memberof": "test/config-parser.js~describe19",
    "testDepth": 1,
    "longname": "test/config-parser.js~describe19.describe25",
    "access": null,
    "description": "the createCompilerHostFromBabelRc method",
    "lineNumber": 67
  },
  {
    "__docId__": 210,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it26",
    "testId": 26,
    "memberof": "test/config-parser.js~describe19.describe25",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe25.it26",
    "access": null,
    "description": "reads from an environment-free file",
    "lineNumber": 80
  },
  {
    "__docId__": 211,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it27",
    "testId": 27,
    "memberof": "test/config-parser.js~describe19.describe25",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe25.it27",
    "access": null,
    "description": "uses the development env when env is unset",
    "lineNumber": 95
  },
  {
    "__docId__": 212,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it28",
    "testId": 28,
    "memberof": "test/config-parser.js~describe19.describe25",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe25.it28",
    "access": null,
    "description": "uses the production env when env is set",
    "lineNumber": 110
  },
  {
    "__docId__": 213,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe29",
    "testId": 29,
    "memberof": "test/config-parser.js~describe19",
    "testDepth": 1,
    "longname": "test/config-parser.js~describe19.describe29",
    "access": null,
    "description": "the createCompilerHostFromConfigFile method",
    "lineNumber": 127
  },
  {
    "__docId__": 214,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it30",
    "testId": 30,
    "memberof": "test/config-parser.js~describe19.describe29",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe29.it30",
    "access": null,
    "description": "reads from an environment-free file",
    "lineNumber": 140
  },
  {
    "__docId__": 215,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it31",
    "testId": 31,
    "memberof": "test/config-parser.js~describe19.describe29",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe29.it31",
    "access": null,
    "description": "uses the development env when env is unset",
    "lineNumber": 155
  },
  {
    "__docId__": 216,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it32",
    "testId": 32,
    "memberof": "test/config-parser.js~describe19.describe29",
    "testDepth": 2,
    "longname": "test/config-parser.js~describe19.describe29.it32",
    "access": null,
    "description": "uses the production env when env is set",
    "lineNumber": 170
  },
  {
    "__docId__": 217,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/electron-smoke-test-app.js",
    "memberof": null,
    "longname": "test/electron-smoke-test-app.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "// NB: Prevent the test runner from picking this up\nif ('type' in process) {\n  let {app, BrowserWindow} = require('electron');\n\n  // Quit when all windows are closed.\n  app.on('window-all-closed', function() {\n    app.quit();\n  });\n\n  app.on('ready', function() {\n    global.mainWindow = new BrowserWindow({\n      width: 800,\n      height: 600,\n      autoHideMenuBar: true\n    });\n    \n    global.mainWindow.loadURL('file://' + __dirname + '/../test/electron-smoke-test.html');\n    global.mainWindow.focus();\n  });\n}\n"
  },
  {
    "__docId__": 218,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/electron-smoke-test.js",
    "memberof": null,
    "longname": "test/electron-smoke-test.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "if ('type' in process) {\n  require('babel-polyfill');\n  const init = require('../lib/config-parser').init;\n\n  init(__dirname + '/..', './electron-smoke-test-app');\n}\n\n/*\nconst path = require('path');\nconst app = require('electron').app;\n\nconst createCompilerHostFromProjectRootSync = require('../lib/config-parser').createCompilerHostFromProjectRootSync;\n\nconst registerRequireExtension = require('../lib/require-hook').default;\nconst initializeProtocolHook = require('../lib/protocol-hook').initializeProtocolHook;\n\nlet compilerHost = createCompilerHostFromProjectRootSync(path.join(__dirname, '..'));\nregisterRequireExtension(compilerHost);\n\nlet protoify = function() { initializeProtocolHook(compilerHost); };\nif (app.isReady()) {\n  protoify();\n} else {\n  app.on('ready', protoify);\n}\n\nrequire('./electron-smoke-test-app');\n*/\n"
  },
  {
    "__docId__": 219,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/file-change-cache.js",
    "memberof": null,
    "longname": "test/file-change-cache.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './support.js';\n\nimport FileChangeCache from '../lib/file-change-cache';\nimport path from 'path';\nimport fs from 'fs';\nimport pify from 'pify';\nconst pfs = pify(fs);\n\ndescribe('The file changed cache', function() {\n  beforeEach(function() {\n    this.fixture = new FileChangeCache(null);\n  });\n\n  it(\"Correctly computes a file hash for a canned file\", async function() {\n    const expectedInfo = {\n      hash: '4a92e95074156e8b46869519c43ddf10b59299a4',\n      hasSourceMap: false,\n      isInNodeModules: false,\n      isMinified: false,\n      isFileBinary: false\n    };\n\n    let input = path.resolve(__dirname, '..', 'test', 'fixtures', 'valid.js');\n    let result = await this.fixture.getHashForPath(input);\n\n    expect(result.sourceCode).to.be.ok;\n    delete result.sourceCode;\n    expect(result).to.deep.equal(expectedInfo);\n  });\n  \n  it(\"Correctly handles binary files\", async function() {\n    const expectedInfo = {\n      hash: '83af4f2b5a3e2dda1a322ac75799eee337d569a5',\n      hasSourceMap: false,\n      isInNodeModules: false,\n      isMinified: false,\n      isFileBinary: true\n    };\n\n    let input = path.resolve(__dirname, '..', 'test', 'fixtures', 'binaryfile.zip');\n    let result = await this.fixture.getHashForPath(input);\n    expect(result.binaryData).to.be.ok;\n    expect(result.binaryData.length > 16).to.be.ok;\n    delete result.binaryData;\n    expect(result).to.deep.equal(expectedInfo);\n  });\n  \n  \n  it(\"Correctly computes a file hash for a canned file syncronously\", function() {\n    const expectedInfo = {\n      hash: '4a92e95074156e8b46869519c43ddf10b59299a4',\n      hasSourceMap: false,\n      isInNodeModules: false,\n      isMinified: false,\n      isFileBinary: false\n    };\n\n    let input = path.resolve(__dirname, '..', 'test', 'fixtures', 'valid.js');\n    let result = this.fixture.getHashForPathSync(input);\n\n    expect(result.sourceCode).to.be.ok;\n    delete result.sourceCode;\n    expect(result).to.deep.equal(expectedInfo);\n  });\n\n  it(\"Doesn't rerun the file hash if you ask for it twice\", async function() {\n    const expectedInfo = {\n      hash: '4a92e95074156e8b46869519c43ddf10b59299a4',\n      hasSourceMap: false,\n      isInNodeModules: false,\n      isMinified: false,\n      isFileBinary: false\n    };\n\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'valid.js');\n    let result = await this.fixture.getHashForPath(input);\n    \n    expect(result.sourceCode).to.be.ok;\n    delete result.sourceCode;\n    expect(result).to.deep.equal(expectedInfo);\n\n    this.fixture.calculateHashForFile = () => Promise.reject(new Error(\"Didn't work\"));\n    result = await this.fixture.getHashForPath(input);\n    \n    // NB: The file hash cache itself shouldn't hold onto file contents, it should\n    // only opportunistically return it if it had to read the contents anyways\n    expect(result.sourceCode).to.be.not.ok;\n    expect(result).to.deep.equal(expectedInfo);\n  });\n\n  it(\"Throws on cache misses in production mode\", function() {\n    this.fixture = new FileChangeCache(true);\n\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'valid.js');\n    expect(this.fixture.getHashForPath(input)).to.eventually.throw(Error);\n  });\n\n  it(\"Successfully saves and loads its cache information\", async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'valid.js');\n    await this.fixture.getHashForPath(input);\n\n    let targetCache = path.join(__dirname, 'fileChangeCache1.json.gz');\n\n    try {\n      await this.fixture.save(targetCache);\n\n      this.fixture = await FileChangeCache.loadFromFile(targetCache, null);\n\n      this.fixture.calculateHashForFile = () => Promise.reject(new Error(\"Didn't work\"));\n      await this.fixture.getHashForPath(input);\n    } finally {\n      fs.unlinkSync(targetCache);\n    }\n  });\n\n  it(\"Detects changes to files and reruns hash\", async function() {\n    const expectedInfo = {\n      hash: '4a92e95074156e8b46869519c43ddf10b59299a4',\n      hasSourceMap: false,\n      isInNodeModules: false,\n      isMinified: false,\n      isFileBinary: false\n    };\n\n    let realInput = path.join(__dirname, '..', 'test', 'fixtures', 'valid.js');\n    let input = path.join(__dirname, 'tempfile.tmp');\n    let contents = await pfs.readFile(realInput);\n    await pfs.writeFile(input, contents);\n    \n    let stat1 = await pfs.stat(realInput);\n    let stat2 = await pfs.stat(input);\n    expect(stat1.size).to.equal(stat2.size);\n    \n    try {\n      let result = await this.fixture.getHashForPath(input);\n\n      expect(result.sourceCode).to.be.ok;\n      delete result.sourceCode;      \n      expect(result).to.deep.equal(expectedInfo);\n        \n      let fd = await pfs.open(input, 'a');\n      await pfs.write(fd, '\\n\\n\\n\\n');\n      await pfs.close(fd);\n\n      // NB: Declaring these as 'var' works around a BabelJS compilation bug\n      // where it can't deal with let + closure scoping\n      var realCalc = this.fixture.calculateHashForFile;\n      var hasCalledCalc = false;\n\n      this.fixture.calculateHashForFile = function(...args) {\n        hasCalledCalc = true;\n        return realCalc(...args);\n      };\n      \n      result = await this.fixture.getHashForPath(input);\n\n      expect(result.sourceCode).to.be.ok;\n      delete result.sourceCode;      \n      \n      expect(result).not.to.deep.equal(expectedInfo);\n      expect(hasCalledCalc).to.be.ok;\n    } finally {\n      fs.unlinkSync(input);\n    }\n  });\n\n  it(\"Successfully finds if a file has a source map\", async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'source_map.js');\n    let result = await this.fixture.getHashForPath(input);\n\n    expect(result.hasSourceMap).to.be.ok;\n  });\n  \n  it(\"Successfully finds if a file has a source map synchronously\", function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'source_map.js');\n    let result = this.fixture.getHashForPathSync(input);\n\n    expect(result.hasSourceMap).to.be.ok;\n  });\n\n  it(\"Successfully finds if a file is minified\", async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'minified.js');\n    let result = await this.fixture.getHashForPath(input);\n\n    expect(result.isMinified).to.be.ok;\n  });\n\n  it(\"Successfully finds if a file is in node_modules\", async function() {\n    let input = path.join(__dirname, '..', 'node_modules', 'electron-compilers', 'package.json');\n    let result = await this.fixture.getHashForPath(input);\n\n    expect(result.isInNodeModules).to.be.ok;\n  });\n});\n"
  },
  {
    "__docId__": 220,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe33",
    "testId": 33,
    "memberof": "test/file-change-cache.js",
    "testDepth": 0,
    "longname": "test/file-change-cache.js~describe33",
    "access": null,
    "description": "The file changed cache",
    "lineNumber": 9
  },
  {
    "__docId__": 221,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it34",
    "testId": 34,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it34",
    "access": null,
    "description": "Correctly computes a file hash for a canned file",
    "lineNumber": 14
  },
  {
    "__docId__": 222,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it35",
    "testId": 35,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it35",
    "access": null,
    "description": "Correctly handles binary files",
    "lineNumber": 31
  },
  {
    "__docId__": 223,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it36",
    "testId": 36,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it36",
    "access": null,
    "description": "Correctly computes a file hash for a canned file syncronously",
    "lineNumber": 49
  },
  {
    "__docId__": 224,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it37",
    "testId": 37,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it37",
    "access": null,
    "description": "Doesn't rerun the file hash if you ask for it twice",
    "lineNumber": 66
  },
  {
    "__docId__": 225,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it38",
    "testId": 38,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it38",
    "access": null,
    "description": "Throws on cache misses in production mode",
    "lineNumber": 91
  },
  {
    "__docId__": 226,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it39",
    "testId": 39,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it39",
    "access": null,
    "description": "Successfully saves and loads its cache information",
    "lineNumber": 98
  },
  {
    "__docId__": 227,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it40",
    "testId": 40,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it40",
    "access": null,
    "description": "Detects changes to files and reruns hash",
    "lineNumber": 116
  },
  {
    "__docId__": 228,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it41",
    "testId": 41,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it41",
    "access": null,
    "description": "Successfully finds if a file has a source map",
    "lineNumber": 167
  },
  {
    "__docId__": 229,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it42",
    "testId": 42,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it42",
    "access": null,
    "description": "Successfully finds if a file has a source map synchronously",
    "lineNumber": 174
  },
  {
    "__docId__": 230,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it43",
    "testId": 43,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it43",
    "access": null,
    "description": "Successfully finds if a file is minified",
    "lineNumber": 181
  },
  {
    "__docId__": 231,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it44",
    "testId": 44,
    "memberof": "test/file-change-cache.js~describe33",
    "testDepth": 1,
    "longname": "test/file-change-cache.js~describe33.it44",
    "access": null,
    "description": "Successfully finds if a file is in node_modules",
    "lineNumber": 188
  },
  {
    "__docId__": 232,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/fixtures/minified.js",
    "memberof": null,
    "longname": "test/fixtures/minified.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "/**\n * @license\n * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n */\n// @version 0.7.15\n!function(){window.WebComponents=window.WebComponents||{flags:{}};var e=\"webcomponents-lite.js\",t=document.querySelector('script[src*=\"'+e+'\"]'),n={};if(!n.noOpts){if(location.search.slice(1).split(\"&\").forEach(function(e){var t,r=e.split(\"=\");r[0]&&(t=r[0].match(/wc-(.+)/))&&(n[t[1]]=r[1]||!0)}),t)for(var r,o=0;r=t.attributes[o];o++)\"src\"!==r.name&&(n[r.name]=r.value||!0);if(n.log&&n.log.split){var i=n.log.split(\",\");n.log={},i.forEach(function(e){n.log[e]=!0})}else n.log={}}n.register&&(window.CustomElements=window.CustomElements||{flags:{}},window.CustomElements.flags.register=n.register),WebComponents.flags=n}(),function(e){\"use strict\";function t(e){return void 0!==h[e]}function n(){s.call(this),this._isInvalid=!0}function r(e){return\"\"==e&&n.call(this),e.toLowerCase()}function o(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,63,96].indexOf(t)?e:encodeURIComponent(e)}function i(e){var t=e.charCodeAt(0);return t>32&&127>t&&-1==[34,35,60,62,96].indexOf(t)?e:encodeURIComponent(e)}function a(e,a,s){function c(e){g.push(e)}var d=a||\"scheme start\",u=0,l=\"\",w=!1,_=!1,g=[];e:for(;(e[u-1]!=p||0==u)&&!this._isInvalid;){var b=e[u];switch(d){case\"scheme start\":if(!b||!m.test(b)){if(a){c(\"Invalid scheme.\");break e}l=\"\",d=\"no scheme\";continue}l+=b.toLowerCase(),d=\"scheme\";break;case\"scheme\":if(b&&v.test(b))l+=b.toLowerCase();else{if(\":\"!=b){if(a){if(p==b)break e;c(\"Code point not allowed in scheme: \"+b);break e}l=\"\",u=0,d=\"no scheme\";continue}if(this._scheme=l,l=\"\",a)break e;t(this._scheme)&&(this._isRelative=!0),d=\"file\"==this._scheme?\"relative\":this._isRelative&&s&&s._scheme==this._scheme?\"relative or authority\":this._isRelative?\"authority first slash\":\"scheme data\"}break;case\"scheme data\":\"?\"==b?(this._query=\"?\",d=\"query\"):\"#\"==b?(this._fragment=\"#\",d=\"fragment\"):p!=b&&\"\t\"!=b&&\"\\n\"!=b&&\"\\r\"!=b&&(this._schemeData+=o(b));break;case\"no scheme\":if(s&&t(s._scheme)){d=\"relative\";continue}c(\"Missing scheme.\"),n.call(this);break;case\"relative or authority\":if(\"/\"!=b||\"/\"!=e[u+1]){c(\"Expected /, got: \"+b),d=\"relative\";continue}d=\"authority ignore slashes\";break;case\"relative\":if(this._isRelative=!0,\"file\"!=this._scheme&&(this._scheme=s._scheme),p==b){this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._username=s._username,this._password=s._password;break e}if(\"/\"==b||\"\\\\\"==b)\"\\\\\"==b&&c(\"\\\\ is an invalid code point.\"),d=\"relative slash\";else if(\"?\"==b)this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=\"?\",this._username=s._username,this._password=s._password,d=\"query\";else{if(\"#\"!=b){var y=e[u+1],E=e[u+2];(\"file\"!=this._scheme||!m.test(b)||\":\"!=y&&\"|\"!=y||p!=E&&\"/\"!=E&&\"\\\\\"!=E&&\"?\"!=E&&\"#\"!=E)&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password,this._path=s._path.slice(),this._path.pop()),d=\"relative path\";continue}this._host=s._host,this._port=s._port,this._path=s._path.slice(),this._query=s._query,this._fragment=\"#\",this._username=s._username,this._password=s._password,d=\"fragment\"}break;case\"relative slash\":if(\"/\"!=b&&\"\\\\\"!=b){\"file\"!=this._scheme&&(this._host=s._host,this._port=s._port,this._username=s._username,this._password=s._password),d=\"relative path\";continue}\"\\\\\"==b&&c(\"\\\\ is an invalid code point.\"),d=\"file\"==this._scheme?\"file host\":\"authority ignore slashes\";break;case\"authority first slash\":if(\"/\"!=b){c(\"Expected '/', got: \"+b),d=\"authority ignore slashes\";continue}d=\"authority second slash\";break;case\"authority second slash\":if(d=\"authority ignore slashes\",\"/\"!=b){c(\"Expected '/', got: \"+b);continue}break;case\"authority ignore slashes\":if(\"/\"!=b&&\"\\\\\"!=b){d=\"authority\";continue}c(\"Expected authority, got: \"+b);break;case\"authority\":if(\"@\"==b){w&&(c(\"@ already seen.\"),l+=\"%40\"),w=!0;for(var L=0;L<l.length;L++){var T=l[L];if(\"\t\"!=T&&\"\\n\"!=T&&\"\\r\"!=T)if(\":\"!=T||null!==this._password){var M=o(T);null!==this._password?this._password+=M:this._username+=M}else this._password=\"\";else c(\"Invalid whitespace in authority.\")}l=\"\"}else{if(p==b||\"/\"==b||\"\\\\\"==b||\"?\"==b||\"#\"==b){u-=l.length,l=\"\",d=\"host\";continue}l+=b}break;case\"file host\":if(p==b||\"/\"==b||\"\\\\\"==b||\"?\"==b||\"#\"==b){2!=l.length||!m.test(l[0])||\":\"!=l[1]&&\"|\"!=l[1]?0==l.length?d=\"relative path start\":(this._host=r.call(this,l),l=\"\",d=\"relative path start\"):d=\"relative path\";continue}\"\t\"==b||\"\\n\"==b||\"\\r\"==b?c(\"Invalid whitespace in file host.\"):l+=b;break;case\"host\":case\"hostname\":if(\":\"!=b||_){if(p==b||\"/\"==b||\"\\\\\"==b||\"?\"==b||\"#\"==b){if(this._host=r.call(this,l),l=\"\",d=\"relative path start\",a)break e;continue}\"\t\"!=b&&\"\\n\"!=b&&\"\\r\"!=b?(\"[\"==b?_=!0:\"]\"==b&&(_=!1),l+=b):c(\"Invalid code point in host/hostname: \"+b)}else if(this._host=r.call(this,l),l=\"\",d=\"port\",\"hostname\"==a)break e;break;case\"port\":if(/[0-9]/.test(b))l+=b;else{if(p==b||\"/\"==b||\"\\\\\"==b||\"?\"==b||\"#\"==b||a){if(\"\"!=l){var N=parseInt(l,10);N!=h[this._scheme]&&(this._port=N+\"\"),l=\"\"}if(a)break e;d=\"relative path start\";continue}\"\t\"==b||\"\\n\"==b||\"\\r\"==b?c(\"Invalid code point in port: \"+b):n.call(this)}break;case\"relative path start\":if(\"\\\\\"==b&&c(\"'\\\\' not allowed in path.\"),d=\"relative path\",\"/\"!=b&&\"\\\\\"!=b)continue;break;case\"relative path\":if(p!=b&&\"/\"!=b&&\"\\\\\"!=b&&(a||\"?\"!=b&&\"#\"!=b))\"\t\"!=b&&\"\\n\"!=b&&\"\\r\"!=b&&(l+=o(b));else{\"\\\\\"==b&&c(\"\\\\ not allowed in relative path.\");var O;(O=f[l.toLowerCase()])&&(l=O),\"..\"==l?(this._path.pop(),\"/\"!=b&&\"\\\\\"!=b&&this._path.push(\"\")):\".\"==l&&\"/\"!=b&&\"\\\\\"!=b?this._path.push(\"\"):\".\"!=l&&(\"file\"==this._scheme&&0==this._path.length&&2==l.length&&m.test(l[0])&&\"|\"==l[1]&&(l=l[0]+\":\"),this._path.push(l)),l=\"\",\"?\"==b?(this._query=\"?\",d=\"query\"):\"#\"==b&&(this._fragment=\"#\",d=\"fragment\")}break;case\"query\":a||\"#\"!=b?p!=b&&\"\t\"!=b&&\"\\n\"!=b&&\"\\r\"!=b&&(this._query+=i(b)):(this._fragment=\"#\",d=\"fragment\");break;case\"fragment\":p!=b&&\"\t\"!=b&&\"\\n\"!=b&&\"\\r\"!=b&&(this._fragment+=b)}u++}}function s(){this._scheme=\"\",this._schemeData=\"\",this._username=\"\",this._password=null,this._host=\"\",this._port=\"\",this._path=[],this._query=\"\",this._fragment=\"\",this._isInvalid=!1,this._isRelative=!1}function c(e,t){void 0===t||t instanceof c||(t=new c(String(t))),this._url=e,s.call(this);var n=e.replace(/^[ \\t\\r\\n\\f]+|[ \\t\\r\\n\\f]+$/g,\"\");a.call(this,n,null,t)}var d=!1;if(!e.forceJURL)try{var u=new URL(\"b\",\"http://a\");u.pathname=\"c%20d\",d=\"http://a/c%20d\"===u.href}catch(l){}if(!d){var h=Object.create(null);h.ftp=21,h.file=0,h.gopher=70,h.http=80,h.https=443,h.ws=80,h.wss=443;var f=Object.create(null);f[\"%2e\"]=\".\",f[\".%2e\"]=\"..\",f[\"%2e.\"]=\"..\",f[\"%2e%2e\"]=\"..\";var p=void 0,m=/[a-zA-Z]/,v=/[a-zA-Z0-9\\+\\-\\.]/;c.prototype={toString:function(){return this.href},get href(){if(this._isInvalid)return this._url;var e=\"\";return(\"\"!=this._username||null!=this._password)&&(e=this._username+(null!=this._password?\":\"+this._password:\"\")+\"@\"),this.protocol+(this._isRelative?\"//\"+e+this.host:\"\")+this.pathname+this._query+this._fragment},set href(e){s.call(this),a.call(this,e)},get protocol(){return this._scheme+\":\"},set protocol(e){this._isInvalid||a.call(this,e+\":\",\"scheme start\")},get host(){return this._isInvalid?\"\":this._port?this._host+\":\"+this._port:this._host},set host(e){!this._isInvalid&&this._isRelative&&a.call(this,e,\"host\")},get hostname(){return this._host},set hostname(e){!this._isInvalid&&this._isRelative&&a.call(this,e,\"hostname\")},get port(){return this._port},set port(e){!this._isInvalid&&this._isRelative&&a.call(this,e,\"port\")},get pathname(){return this._isInvalid?\"\":this._isRelative?\"/\"+this._path.join(\"/\"):this._schemeData},set pathname(e){!this._isInvalid&&this._isRelative&&(this._path=[],a.call(this,e,\"relative path start\"))},get search(){return this._isInvalid||!this._query||\"?\"==this._query?\"\":this._query},set search(e){!this._isInvalid&&this._isRelative&&(this._query=\"?\",\"?\"==e[0]&&(e=e.slice(1)),a.call(this,e,\"query\"))},get hash(){return this._isInvalid||!this._fragment||\"#\"==this._fragment?\"\":this._fragment},set hash(e){this._isInvalid||(this._fragment=\"#\",\"#\"==e[0]&&(e=e.slice(1)),a.call(this,e,\"fragment\"))},get origin(){var e;if(this._isInvalid||!this._scheme)return\"\";switch(this._scheme){case\"data\":case\"file\":case\"javascript\":case\"mailto\":return\"null\"}return e=this.host,e?this._scheme+\"://\"+e:\"\"}};var w=e.URL;w&&(c.createObjectURL=function(e){return w.createObjectURL.apply(w,arguments)},c.revokeObjectURL=function(e){w.revokeObjectURL(e)}),e.URL=c}}(self),\"undefined\"==typeof WeakMap&&!function(){var e=Object.defineProperty,t=Date.now()%1e9,n=function(){this.name=\"__st\"+(1e9*Math.random()>>>0)+(t++ +\"__\")};n.prototype={set:function(t,n){var r=t[this.name];return r&&r[0]===t?r[1]=n:e(t,this.name,{value:[t,n],writable:!0}),this},get:function(e){var t;return(t=e[this.name])&&t[0]===e?t[1]:void 0},\"delete\":function(e){var t=e[this.name];return t&&t[0]===e?(t[0]=t[1]=void 0,!0):!1},has:function(e){var t=e[this.name];return t?t[0]===e:!1}},window.WeakMap=n}(),function(e){function t(e){b.push(e),g||(g=!0,m(r))}function n(e){return window.ShadowDOMPolyfill&&window.ShadowDOMPolyfill.wrapIfNeeded(e)||e}function r(){g=!1;var e=b;b=[],e.sort(function(e,t){return e.uid_-t.uid_});var t=!1;e.forEach(function(e){var n=e.takeRecords();o(e),n.length&&(e.callback_(n,e),t=!0)}),t&&r()}function o(e){e.nodes_.forEach(function(t){var n=v.get(t);n&&n.forEach(function(t){t.observer===e&&t.removeTransientObservers()})})}function i(e,t){for(var n=e;n;n=n.parentNode){var r=v.get(n);if(r)for(var o=0;o<r.length;o++){var i=r[o],a=i.options;if(n===e||a.subtree){var s=t(a);s&&i.enqueue(s)}}}}function a(e){this.callback_=e,this.nodes_=[],this.records_=[],this.uid_=++y}function s(e,t){this.type=e,this.target=t,this.addedNodes=[],this.removedNodes=[],this.previousSibling=null,this.nextSibling=null,this.attributeName=null,this.attributeNamespace=null,this.oldValue=null}function c(e){var t=new s(e.type,e.target);return t.addedNodes=e.addedNodes.slice(),t.removedNodes=e.removedNodes.slice(),t.previousSibling=e.previousSibling,t.nextSibling=e.nextSibling,t.attributeName=e.attributeName,t.attributeNamespace=e.attributeNamespace,t.oldValue=e.oldValue,t}function d(e,t){return E=new s(e,t)}function u(e){return L?L:(L=c(E),L.oldValue=e,L)}function l(){E=L=void 0}function h(e){return e===L||e===E}function f(e,t){return e===t?e:L&&h(e)?L:null}function p(e,t,n){this.observer=e,this.target=t,this.options=n,this.transientObservedNodes=[]}if(!e.JsMutationObserver){var m,v=new WeakMap;if(/Trident|Edge/.test(navigator.userAgent))m=setTimeout;else if(window.setImmediate)m=window.setImmediate;else{var w=[],_=String(Math.random());window.addEventListener(\"message\",function(e){if(e.data===_){var t=w;w=[],t.forEach(function(e){e()})}}),m=function(e){w.push(e),window.postMessage(_,\"*\")}}var g=!1,b=[],y=0;a.prototype={observe:function(e,t){if(e=n(e),!t.childList&&!t.attributes&&!t.characterData||t.attributeOldValue&&!t.attributes||t.attributeFilter&&t.attributeFilter.length&&!t.attributes||t.characterDataOldValue&&!t.characterData)throw new SyntaxError;var r=v.get(e);r||v.set(e,r=[]);for(var o,i=0;i<r.length;i++)if(r[i].observer===this){o=r[i],o.removeListeners(),o.options=t;break}o||(o=new p(this,e,t),r.push(o),this.nodes_.push(e)),o.addListeners()},disconnect:function(){this.nodes_.forEach(function(e){for(var t=v.get(e),n=0;n<t.length;n++){var r=t[n];if(r.observer===this){r.removeListeners(),t.splice(n,1);break}}},this),this.records_=[]},takeRecords:function(){var e=this.records_;return this.records_=[],e}};var E,L;p.prototype={enqueue:function(e){var n=this.observer.records_,r=n.length;if(n.length>0){var o=n[r-1],i=f(o,e);if(i)return void(n[r-1]=i)}else t(this.observer);n[r]=e},addListeners:function(){this.addListeners_(this.target)},addListeners_:function(e){var t=this.options;t.attributes&&e.addEventListener(\"DOMAttrModified\",this,!0),t.characterData&&e.addEventListener(\"DOMCharacterDataModified\",this,!0),t.childList&&e.addEventListener(\"DOMNodeInserted\",this,!0),(t.childList||t.subtree)&&e.addEventListener(\"DOMNodeRemoved\",this,!0)},removeListeners:function(){this.removeListeners_(this.target)},removeListeners_:function(e){var t=this.options;t.attributes&&e.removeEventListener(\"DOMAttrModified\",this,!0),t.characterData&&e.removeEventListener(\"DOMCharacterDataModified\",this,!0),t.childList&&e.removeEventListener(\"DOMNodeInserted\",this,!0),(t.childList||t.subtree)&&e.removeEventListener(\"DOMNodeRemoved\",this,!0)},addTransientObserver:function(e){if(e!==this.target){this.addListeners_(e),this.transientObservedNodes.push(e);var t=v.get(e);t||v.set(e,t=[]),t.push(this)}},removeTransientObservers:function(){var e=this.transientObservedNodes;this.transientObservedNodes=[],e.forEach(function(e){this.removeListeners_(e);for(var t=v.get(e),n=0;n<t.length;n++)if(t[n]===this){t.splice(n,1);break}},this)},handleEvent:function(e){switch(e.stopImmediatePropagation(),e.type){case\"DOMAttrModified\":var t=e.attrName,n=e.relatedNode.namespaceURI,r=e.target,o=new d(\"attributes\",r);o.attributeName=t,o.attributeNamespace=n;var a=e.attrChange===MutationEvent.ADDITION?null:e.prevValue;i(r,function(e){return!e.attributes||e.attributeFilter&&e.attributeFilter.length&&-1===e.attributeFilter.indexOf(t)&&-1===e.attributeFilter.indexOf(n)?void 0:e.attributeOldValue?u(a):o});break;case\"DOMCharacterDataModified\":var r=e.target,o=d(\"characterData\",r),a=e.prevValue;i(r,function(e){return e.characterData?e.characterDataOldValue?u(a):o:void 0});break;case\"DOMNodeRemoved\":this.addTransientObserver(e.target);case\"DOMNodeInserted\":var s,c,h=e.target;\"DOMNodeInserted\"===e.type?(s=[h],c=[]):(s=[],c=[h]);var f=h.previousSibling,p=h.nextSibling,o=d(\"childList\",e.target.parentNode);o.addedNodes=s,o.removedNodes=c,o.previousSibling=f,o.nextSibling=p,i(e.relatedNode,function(e){return e.childList?o:void 0})}l()}},e.JsMutationObserver=a,e.MutationObserver||(e.MutationObserver=a,a._isPolyfilled=!0)}}(self),window.HTMLImports=window.HTMLImports||{flags:{}},function(e){function t(e,t){t=t||p,r(function(){i(e,t)},t)}function n(e){return\"complete\"===e.readyState||e.readyState===w}function r(e,t){if(n(t))e&&e();else{var o=function(){(\"complete\"===t.readyState||t.readyState===w)&&(t.removeEventListener(_,o),r(e,t))};t.addEventListener(_,o)}}function o(e){e.target.__loaded=!0}function i(e,t){function n(){c==d&&e&&e({allImports:s,loadedImports:u,errorImports:l})}function r(e){o(e),u.push(this),c++,n()}function i(e){l.push(this),c++,n()}var s=t.querySelectorAll(\"link[rel=import]\"),c=0,d=s.length,u=[],l=[];if(d)for(var h,f=0;d>f&&(h=s[f]);f++)a(h)?(c++,n()):(h.addEventListener(\"load\",r),h.addEventListener(\"error\",i));else n()}function a(e){return l?e.__loaded||e[\"import\"]&&\"loading\"!==e[\"import\"].readyState:e.__importParsed}function s(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)c(t)&&d(t)}function c(e){return\"link\"===e.localName&&\"import\"===e.rel}function d(e){var t=e[\"import\"];t?o({target:e}):(e.addEventListener(\"load\",o),e.addEventListener(\"error\",o))}var u=\"import\",l=Boolean(u in document.createElement(\"link\")),h=Boolean(window.ShadowDOMPolyfill),f=function(e){return h?window.ShadowDOMPolyfill.wrapIfNeeded(e):e},p=f(document),m={get:function(){var e=window.HTMLImports.currentScript||document.currentScript||(\"complete\"!==document.readyState?document.scripts[document.scripts.length-1]:null);return f(e)},configurable:!0};Object.defineProperty(document,\"_currentScript\",m),Object.defineProperty(p,\"_currentScript\",m);var v=/Trident/.test(navigator.userAgent),w=v?\"complete\":\"interactive\",_=\"readystatechange\";l&&(new MutationObserver(function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.addedNodes&&s(t.addedNodes)}).observe(document.head,{childList:!0}),function(){if(\"loading\"===document.readyState)for(var e,t=document.querySelectorAll(\"link[rel=import]\"),n=0,r=t.length;r>n&&(e=t[n]);n++)d(e)}()),t(function(e){window.HTMLImports.ready=!0,window.HTMLImports.readyTime=(new Date).getTime();var t=p.createEvent(\"CustomEvent\");t.initCustomEvent(\"HTMLImportsLoaded\",!0,!0,e),p.dispatchEvent(t)}),e.IMPORT_LINK_TYPE=u,e.useNative=l,e.rootDocument=p,e.whenReady=t,e.isIE=v}(window.HTMLImports),function(e){var t=[],n=function(e){t.push(e)},r=function(){t.forEach(function(t){t(e)})};e.addModule=n,e.initializeModules=r}(window.HTMLImports),window.HTMLImports.addModule(function(e){var t=/(url\\()([^)]*)(\\))/g,n=/(@import[\\s]+(?!url\\())([^;]*)(;)/g,r={resolveUrlsInStyle:function(e,t){var n=e.ownerDocument,r=n.createElement(\"a\");return e.textContent=this.resolveUrlsInCssText(e.textContent,t,r),e},resolveUrlsInCssText:function(e,r,o){var i=this.replaceUrls(e,o,r,t);return i=this.replaceUrls(i,o,r,n)},replaceUrls:function(e,t,n,r){return e.replace(r,function(e,r,o,i){var a=o.replace(/[\"']/g,\"\");return n&&(a=new URL(a,n).href),t.href=a,a=t.href,r+\"'\"+a+\"'\"+i})}};e.path=r}),window.HTMLImports.addModule(function(e){var t={async:!0,ok:function(e){return e.status>=200&&e.status<300||304===e.status||0===e.status},load:function(n,r,o){var i=new XMLHttpRequest;return(e.flags.debug||e.flags.bust)&&(n+=\"?\"+Math.random()),i.open(\"GET\",n,t.async),i.addEventListener(\"readystatechange\",function(e){if(4===i.readyState){var n=i.getResponseHeader(\"Location\"),a=null;if(n)var a=\"/\"===n.substr(0,1)?location.origin+n:n;r.call(o,!t.ok(i)&&i,i.response||i.responseText,a)}}),i.send(),i},loadDocument:function(e,t,n){this.load(e,t,n).responseType=\"document\"}};e.xhr=t}),window.HTMLImports.addModule(function(e){var t=e.xhr,n=e.flags,r=function(e,t){this.cache={},this.onload=e,this.oncomplete=t,this.inflight=0,this.pending={}};r.prototype={addNodes:function(e){this.inflight+=e.length;for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)this.require(t);this.checkDone()},addNode:function(e){this.inflight++,this.require(e),this.checkDone()},require:function(e){var t=e.src||e.href;e.__nodeUrl=t,this.dedupe(t,e)||this.fetch(t,e)},dedupe:function(e,t){if(this.pending[e])return this.pending[e].push(t),!0;return this.cache[e]?(this.onload(e,t,this.cache[e]),this.tail(),!0):(this.pending[e]=[t],!1)},fetch:function(e,r){if(n.load&&console.log(\"fetch\",e,r),e)if(e.match(/^data:/)){var o=e.split(\",\"),i=o[0],a=o[1];a=i.indexOf(\";base64\")>-1?atob(a):decodeURIComponent(a),setTimeout(function(){this.receive(e,r,null,a)}.bind(this),0)}else{var s=function(t,n,o){this.receive(e,r,t,n,o)}.bind(this);t.load(e,s)}else setTimeout(function(){this.receive(e,r,{error:\"href must be specified\"},null)}.bind(this),0)},receive:function(e,t,n,r,o){this.cache[e]=r;for(var i,a=this.pending[e],s=0,c=a.length;c>s&&(i=a[s]);s++)this.onload(e,i,r,n,o),this.tail();this.pending[e]=null},tail:function(){--this.inflight,this.checkDone()},checkDone:function(){this.inflight||this.oncomplete()}},e.Loader=r}),window.HTMLImports.addModule(function(e){var t=function(e){this.addCallback=e,this.mo=new MutationObserver(this.handler.bind(this))};t.prototype={handler:function(e){for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)\"childList\"===t.type&&t.addedNodes.length&&this.addedNodes(t.addedNodes)},addedNodes:function(e){this.addCallback&&this.addCallback(e);for(var t,n=0,r=e.length;r>n&&(t=e[n]);n++)t.children&&t.children.length&&this.addedNodes(t.children)},observe:function(e){this.mo.observe(e,{childList:!0,subtree:!0})}},e.Observer=t}),window.HTMLImports.addModule(function(e){function t(e){return\"link\"===e.localName&&e.rel===u}function n(e){var t=r(e);return\"data:text/javascript;charset=utf-8,\"+encodeURIComponent(t)}function r(e){return e.textContent+o(e)}function o(e){var t=e.ownerDocument;t.__importedScripts=t.__importedScripts||0;var n=e.ownerDocument.baseURI,r=t.__importedScripts?\"-\"+t.__importedScripts:\"\";return t.__importedScripts++,\"\\n//# sourceURL=\"+n+r+\".js\\n\"}function i(e){var t=e.ownerDocument.createElement(\"style\");return t.textContent=e.textContent,a.resolveUrlsInStyle(t),t}var a=e.path,s=e.rootDocument,c=e.flags,d=e.isIE,u=e.IMPORT_LINK_TYPE,l=\"link[rel=\"+u+\"]\",h={documentSelectors:l,importsSelectors:[l,\"link[rel=stylesheet]:not([type])\",\"style:not([type])\",\"script:not([type])\",'script[type=\"application/javascript\"]','script[type=\"text/javascript\"]'].join(\",\"),map:{link:\"parseLink\",script:\"parseScript\",style:\"parseStyle\"},dynamicElements:[],parseNext:function(){var e=this.nextToParse();e&&this.parse(e)},parse:function(e){if(this.isParsed(e))return void(c.parse&&console.log(\"[%s] is already parsed\",e.localName));var t=this[this.map[e.localName]];t&&(this.markParsing(e),t.call(this,e))},parseDynamic:function(e,t){this.dynamicElements.push(e),t||this.parseNext()},markParsing:function(e){c.parse&&console.log(\"parsing\",e),this.parsingElement=e},markParsingComplete:function(e){e.__importParsed=!0,this.markDynamicParsingComplete(e),e.__importElement&&(e.__importElement.__importParsed=!0,this.markDynamicParsingComplete(e.__importElement)),this.parsingElement=null,c.parse&&console.log(\"completed\",e)},markDynamicParsingComplete:function(e){var t=this.dynamicElements.indexOf(e);t>=0&&this.dynamicElements.splice(t,1)},parseImport:function(e){if(e[\"import\"]=e.__doc,window.HTMLImports.__importsParsingHook&&window.HTMLImports.__importsParsingHook(e),e[\"import\"]&&(e[\"import\"].__importParsed=!0),this.markParsingComplete(e),e.__resource&&!e.__error?e.dispatchEvent(new CustomEvent(\"load\",{bubbles:!1})):e.dispatchEvent(new CustomEvent(\"error\",{bubbles:!1})),e.__pending)for(var t;e.__pending.length;)t=e.__pending.shift(),t&&t({target:e});this.parseNext()},parseLink:function(e){t(e)?this.parseImport(e):(e.href=e.href,this.parseGeneric(e))},parseStyle:function(e){var t=e;e=i(e),t.__appliedElement=e,e.__importElement=t,this.parseGeneric(e)},parseGeneric:function(e){this.trackElement(e),this.addElementToDocument(e)},rootImportForElement:function(e){for(var t=e;t.ownerDocument.__importLink;)t=t.ownerDocument.__importLink;return t},addElementToDocument:function(e){var t=this.rootImportForElement(e.__importElement||e);t.parentNode.insertBefore(e,t)},trackElement:function(e,t){var n=this,r=function(o){e.removeEventListener(\"load\",r),e.removeEventListener(\"error\",r),t&&t(o),n.markParsingComplete(e),n.parseNext()};if(e.addEventListener(\"load\",r),e.addEventListener(\"error\",r),d&&\"style\"===e.localName){var o=!1;if(-1==e.textContent.indexOf(\"@import\"))o=!0;else if(e.sheet){o=!0;for(var i,a=e.sheet.cssRules,s=a?a.length:0,c=0;s>c&&(i=a[c]);c++)i.type===CSSRule.IMPORT_RULE&&(o=o&&Boolean(i.styleSheet))}o&&setTimeout(function(){e.dispatchEvent(new CustomEvent(\"load\",{bubbles:!1}))})}},parseScript:function(t){var r=document.createElement(\"script\");r.__importElement=t,r.src=t.src?t.src:n(t),e.currentScript=t,this.trackElement(r,function(t){r.parentNode&&r.parentNode.removeChild(r),e.currentScript=null}),this.addElementToDocument(r)},nextToParse:function(){return this._mayParse=[],!this.parsingElement&&(this.nextToParseInDoc(s)||this.nextToParseDynamic())},nextToParseInDoc:function(e,n){if(e&&this._mayParse.indexOf(e)<0){this._mayParse.push(e);for(var r,o=e.querySelectorAll(this.parseSelectorsForNode(e)),i=0,a=o.length;a>i&&(r=o[i]);i++)if(!this.isParsed(r))return this.hasResource(r)?t(r)?this.nextToParseInDoc(r.__doc,r):r:void 0}return n},nextToParseDynamic:function(){return this.dynamicElements[0]},parseSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===s?this.documentSelectors:this.importsSelectors},isParsed:function(e){return e.__importParsed},needsDynamicParsing:function(e){return this.dynamicElements.indexOf(e)>=0},hasResource:function(e){return t(e)&&void 0===e.__doc?!1:!0}};e.parser=h,e.IMPORT_SELECTOR=l}),window.HTMLImports.addModule(function(e){function t(e){return n(e,a)}function n(e,t){return\"link\"===e.localName&&e.getAttribute(\"rel\")===t}function r(e){return!!Object.getOwnPropertyDescriptor(e,\"baseURI\")}function o(e,t){var n=document.implementation.createHTMLDocument(a);n._URL=t;var o=n.createElement(\"base\");o.setAttribute(\"href\",t),n.baseURI||r(n)||Object.defineProperty(n,\"baseURI\",{value:t});var i=n.createElement(\"meta\");return i.setAttribute(\"charset\",\"utf-8\"),n.head.appendChild(i),n.head.appendChild(o),n.body.innerHTML=e,window.HTMLTemplateElement&&HTMLTemplateElement.bootstrap&&HTMLTemplateElement.bootstrap(n),n}var i=e.flags,a=e.IMPORT_LINK_TYPE,s=e.IMPORT_SELECTOR,c=e.rootDocument,d=e.Loader,u=e.Observer,l=e.parser,h={documents:{},documentPreloadSelectors:s,importsPreloadSelectors:[s].join(\",\"),loadNode:function(e){f.addNode(e)},loadSubtree:function(e){var t=this.marshalNodes(e);f.addNodes(t)},marshalNodes:function(e){return e.querySelectorAll(this.loadSelectorsForNode(e))},loadSelectorsForNode:function(e){var t=e.ownerDocument||e;return t===c?this.documentPreloadSelectors:this.importsPreloadSelectors},loaded:function(e,n,r,a,s){if(i.load&&console.log(\"loaded\",e,n),n.__resource=r,n.__error=a,t(n)){var c=this.documents[e];void 0===c&&(c=a?null:o(r,s||e),c&&(c.__importLink=n,this.bootDocument(c)),this.documents[e]=c),n.__doc=c}l.parseNext()},bootDocument:function(e){this.loadSubtree(e),this.observer.observe(e),l.parseNext()},loadedAll:function(){l.parseNext()}},f=new d(h.loaded.bind(h),h.loadedAll.bind(h));if(h.observer=new u,!document.baseURI){var p={get:function(){var e=document.querySelector(\"base\");return e?e.href:window.location.href},configurable:!0};Object.defineProperty(document,\"baseURI\",p),Object.defineProperty(c,\"baseURI\",p)}e.importer=h,e.importLoader=f}),window.HTMLImports.addModule(function(e){var t=e.parser,n=e.importer,r={added:function(e){for(var r,o,i,a,s=0,c=e.length;c>s&&(a=e[s]);s++)r||(r=a.ownerDocument,o=t.isParsed(r)),i=this.shouldLoadNode(a),i&&n.loadNode(a),this.shouldParseNode(a)&&o&&t.parseDynamic(a,i)},shouldLoadNode:function(e){return 1===e.nodeType&&o.call(e,n.loadSelectorsForNode(e))},shouldParseNode:function(e){return 1===e.nodeType&&o.call(e,t.parseSelectorsForNode(e))}};n.observer.addCallback=r.added.bind(r);var o=HTMLElement.prototype.matches||HTMLElement.prototype.matchesSelector||HTMLElement.prototype.webkitMatchesSelector||HTMLElement.prototype.mozMatchesSelector||HTMLElement.prototype.msMatchesSelector}),function(e){function t(){window.HTMLImports.importer.bootDocument(o)}var n=e.initializeModules,r=e.isIE;if(!e.useNative){(!window.CustomEvent||r&&\"function\"!=typeof window.CustomEvent)&&(window.CustomEvent=function(e,t){t=t||{};var n=document.createEvent(\"CustomEvent\");return n.initCustomEvent(e,Boolean(t.bubbles),Boolean(t.cancelable),t.detail),n.preventDefault=function(){Object.defineProperty(this,\"defaultPrevented\",{get:function(){return!0}})},n},window.CustomEvent.prototype=window.Event.prototype),n();var o=e.rootDocument;\"complete\"===document.readyState||\"interactive\"===document.readyState&&!window.attachEvent?t():document.addEventListener(\"DOMContentLoaded\",t)}}(window.HTMLImports),window.CustomElements=window.CustomElements||{flags:{}},function(e){var t=e.flags,n=[],r=function(e){n.push(e)},o=function(){n.forEach(function(t){t(e)})};e.addModule=r,e.initializeModules=o,e.hasNative=Boolean(document.registerElement),e.isIE=/Trident/.test(navigator.userAgent),e.useNative=!t.register&&e.hasNative&&!window.ShadowDOMPolyfill&&(!window.HTMLImports||window.HTMLImports.useNative)}(window.CustomElements),window.CustomElements.addModule(function(e){function t(e,t){n(e,function(e){return t(e)?!0:void r(e,t)}),r(e,t)}function n(e,t,r){var o=e.firstElementChild;if(!o)for(o=e.firstChild;o&&o.nodeType!==Node.ELEMENT_NODE;)o=o.nextSibling;for(;o;)t(o,r)!==!0&&n(o,t,r),o=o.nextElementSibling;return null}function r(e,n){for(var r=e.shadowRoot;r;)t(r,n),r=r.olderShadowRoot}function o(e,t){i(e,t,[])}function i(e,t,n){if(e=window.wrap(e),!(n.indexOf(e)>=0)){n.push(e);for(var r,o=e.querySelectorAll(\"link[rel=\"+a+\"]\"),s=0,c=o.length;c>s&&(r=o[s]);s++)r[\"import\"]&&i(r[\"import\"],t,n);t(e)}}var a=window.HTMLImports?window.HTMLImports.IMPORT_LINK_TYPE:\"none\";e.forDocumentTree=o,e.forSubtree=t}),window.CustomElements.addModule(function(e){function t(e,t){return n(e,t)||r(e,t)}function n(t,n){return e.upgrade(t,n)?!0:void(n&&a(t))}function r(e,t){g(e,function(e){return n(e,t)?!0:void 0})}function o(e){L.push(e),E||(E=!0,setTimeout(i))}function i(){E=!1;for(var e,t=L,n=0,r=t.length;r>n&&(e=t[n]);n++)e();L=[]}function a(e){y?o(function(){s(e)}):s(e)}function s(e){e.__upgraded__&&!e.__attached&&(e.__attached=!0,e.attachedCallback&&e.attachedCallback())}function c(e){d(e),g(e,function(e){d(e)})}function d(e){y?o(function(){u(e)}):u(e)}function u(e){e.__upgraded__&&e.__attached&&(e.__attached=!1,e.detachedCallback&&e.detachedCallback())}function l(e){for(var t=e,n=window.wrap(document);t;){if(t==n)return!0;t=t.parentNode||t.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&t.host}}function h(e){if(e.shadowRoot&&!e.shadowRoot.__watched){_.dom&&console.log(\"watching shadow-root for: \",e.localName);for(var t=e.shadowRoot;t;)m(t),t=t.olderShadowRoot}}function f(e,n){if(_.dom){var r=n[0];if(r&&\"childList\"===r.type&&r.addedNodes&&r.addedNodes){for(var o=r.addedNodes[0];o&&o!==document&&!o.host;)o=o.parentNode;var i=o&&(o.URL||o._URL||o.host&&o.host.localName)||\"\";i=i.split(\"/?\").shift().split(\"/\").pop()}console.group(\"mutations (%d) [%s]\",n.length,i||\"\")}var a=l(e);n.forEach(function(e){\"childList\"===e.type&&(T(e.addedNodes,function(e){e.localName&&t(e,a)}),T(e.removedNodes,function(e){e.localName&&c(e)}))}),_.dom&&console.groupEnd()}function p(e){for(e=window.wrap(e),e||(e=window.wrap(document));e.parentNode;)e=e.parentNode;var t=e.__observer;t&&(f(e,t.takeRecords()),i())}function m(e){if(!e.__observer){var t=new MutationObserver(f.bind(this,e));t.observe(e,{childList:!0,subtree:!0}),e.__observer=t}}function v(e){e=window.wrap(e),_.dom&&console.group(\"upgradeDocument: \",e.baseURI.split(\"/\").pop());var n=e===window.wrap(document);t(e,n),m(e),_.dom&&console.groupEnd()}function w(e){b(e,v)}var _=e.flags,g=e.forSubtree,b=e.forDocumentTree,y=window.MutationObserver._isPolyfilled&&_[\"throttle-attached\"];e.hasPolyfillMutations=y,e.hasThrottledAttached=y;var E=!1,L=[],T=Array.prototype.forEach.call.bind(Array.prototype.forEach),M=Element.prototype.createShadowRoot;M&&(Element.prototype.createShadowRoot=function(){var e=M.call(this);return window.CustomElements.watchShadow(this),e}),e.watchShadow=h,e.upgradeDocumentTree=w,e.upgradeDocument=v,e.upgradeSubtree=r,e.upgradeAll=t,e.attached=a,e.takeRecords=p}),window.CustomElements.addModule(function(e){function t(t,r){if(!t.__upgraded__&&t.nodeType===Node.ELEMENT_NODE){var o=t.getAttribute(\"is\"),i=e.getRegisteredDefinition(t.localName)||e.getRegisteredDefinition(o);if(i&&(o&&i.tag==t.localName||!o&&!i[\"extends\"]))return n(t,i,r)}}function n(t,n,o){return a.upgrade&&console.group(\"upgrade:\",t.localName),n.is&&t.setAttribute(\"is\",n.is),r(t,n),t.__upgraded__=!0,i(t),o&&e.attached(t),e.upgradeSubtree(t,o),a.upgrade&&console.groupEnd(),t}function r(e,t){Object.__proto__?e.__proto__=t.prototype:(o(e,t.prototype,t[\"native\"]),e.__proto__=t.prototype)}function o(e,t,n){for(var r={},o=t;o!==n&&o!==HTMLElement.prototype;){for(var i,a=Object.getOwnPropertyNames(o),s=0;i=a[s];s++)r[i]||(Object.defineProperty(e,i,Object.getOwnPropertyDescriptor(o,i)),r[i]=1);o=Object.getPrototypeOf(o)}}function i(e){e.createdCallback&&e.createdCallback()}var a=e.flags;e.upgrade=t,e.upgradeWithDefinition=n,e.implementPrototype=r}),window.CustomElements.addModule(function(e){function t(t,r){var c=r||{};if(!t)throw new Error(\"document.registerElement: first argument `name` must not be empty\");if(t.indexOf(\"-\")<0)throw new Error(\"document.registerElement: first argument ('name') must contain a dash ('-'). Argument provided was '\"+String(t)+\"'.\");if(o(t))throw new Error(\"Failed to execute 'registerElement' on 'Document': Registration failed for type '\"+String(t)+\"'. The type name is invalid.\");if(d(t))throw new Error(\"DuplicateDefinitionError: a type with name '\"+String(t)+\"' is already registered\");return c.prototype||(c.prototype=Object.create(HTMLElement.prototype)),c.__name=t.toLowerCase(),c.lifecycle=c.lifecycle||{},c.ancestry=i(c[\"extends\"]),a(c),s(c),n(c.prototype),u(c.__name,c),c.ctor=l(c),c.ctor.prototype=c.prototype,c.prototype.constructor=c.ctor,e.ready&&w(document),c.ctor}function n(e){if(!e.setAttribute._polyfilled){var t=e.setAttribute;e.setAttribute=function(e,n){\nr.call(this,e,n,t)};var n=e.removeAttribute;e.removeAttribute=function(e){r.call(this,e,null,n)},e.setAttribute._polyfilled=!0}}function r(e,t,n){e=e.toLowerCase();var r=this.getAttribute(e);n.apply(this,arguments);var o=this.getAttribute(e);this.attributeChangedCallback&&o!==r&&this.attributeChangedCallback(e,r,o)}function o(e){for(var t=0;t<E.length;t++)if(e===E[t])return!0}function i(e){var t=d(e);return t?i(t[\"extends\"]).concat([t]):[]}function a(e){for(var t,n=e[\"extends\"],r=0;t=e.ancestry[r];r++)n=t.is&&t.tag;e.tag=n||e.__name,n&&(e.is=e.__name)}function s(e){if(!Object.__proto__){var t=HTMLElement.prototype;if(e.is){var n=document.createElement(e.tag);t=Object.getPrototypeOf(n)}for(var r,o=e.prototype,i=!1;o;)o==t&&(i=!0),r=Object.getPrototypeOf(o),r&&(o.__proto__=r),o=r;i||console.warn(e.tag+\" prototype not found in prototype chain for \"+e.is),e[\"native\"]=t}}function c(e){return g(M(e.tag),e)}function d(e){return e?L[e.toLowerCase()]:void 0}function u(e,t){L[e]=t}function l(e){return function(){return c(e)}}function h(e,t,n){return e===T?f(t,n):N(e,t)}function f(e,t){e&&(e=e.toLowerCase()),t&&(t=t.toLowerCase());var n=d(t||e);if(n){if(e==n.tag&&t==n.is)return new n.ctor;if(!t&&!n.is)return new n.ctor}var r;return t?(r=f(e),r.setAttribute(\"is\",t),r):(r=M(e),e.indexOf(\"-\")>=0&&b(r,HTMLElement),r)}function p(e,t){var n=e[t];e[t]=function(){var e=n.apply(this,arguments);return _(e),e}}var m,v=e.isIE,w=e.upgradeDocumentTree,_=e.upgradeAll,g=e.upgradeWithDefinition,b=e.implementPrototype,y=e.useNative,E=[\"annotation-xml\",\"color-profile\",\"font-face\",\"font-face-src\",\"font-face-uri\",\"font-face-format\",\"font-face-name\",\"missing-glyph\"],L={},T=\"http://www.w3.org/1999/xhtml\",M=document.createElement.bind(document),N=document.createElementNS.bind(document);m=Object.__proto__||y?function(e,t){return e instanceof t}:function(e,t){if(e instanceof t)return!0;for(var n=e;n;){if(n===t.prototype)return!0;n=n.__proto__}return!1},p(Node.prototype,\"cloneNode\"),p(document,\"importNode\"),v&&!function(){var e=document.importNode;document.importNode=function(){var t=e.apply(document,arguments);if(t.nodeType==t.DOCUMENT_FRAGMENT_NODE){var n=document.createDocumentFragment();return n.appendChild(t),n}return t}}(),document.registerElement=t,document.createElement=f,document.createElementNS=h,e.registry=L,e[\"instanceof\"]=m,e.reservedTagList=E,e.getRegisteredDefinition=d,document.register=document.registerElement}),function(e){function t(){a(window.wrap(document)),window.CustomElements.ready=!0;var e=window.requestAnimationFrame||function(e){setTimeout(e,16)};e(function(){setTimeout(function(){window.CustomElements.readyTime=Date.now(),window.HTMLImports&&(window.CustomElements.elapsed=window.CustomElements.readyTime-window.HTMLImports.readyTime),document.dispatchEvent(new CustomEvent(\"WebComponentsReady\",{bubbles:!0}))})})}var n=e.useNative,r=e.initializeModules,o=e.isIE;if(n){var i=function(){};e.watchShadow=i,e.upgrade=i,e.upgradeAll=i,e.upgradeDocumentTree=i,e.upgradeSubtree=i,e.takeRecords=i,e[\"instanceof\"]=function(e,t){return e instanceof t}}else r();var a=e.upgradeDocumentTree,s=e.upgradeDocument;if(window.wrap||(window.ShadowDOMPolyfill?(window.wrap=window.ShadowDOMPolyfill.wrapIfNeeded,window.unwrap=window.ShadowDOMPolyfill.unwrapIfNeeded):window.wrap=window.unwrap=function(e){return e}),window.HTMLImports&&(window.HTMLImports.__importsParsingHook=function(e){e[\"import\"]&&s(wrap(e[\"import\"]))}),(!window.CustomEvent||o&&\"function\"!=typeof window.CustomEvent)&&(window.CustomEvent=function(e,t){t=t||{};var n=document.createEvent(\"CustomEvent\");return n.initCustomEvent(e,Boolean(t.bubbles),Boolean(t.cancelable),t.detail),n.preventDefault=function(){Object.defineProperty(this,\"defaultPrevented\",{get:function(){return!0}})},n},window.CustomEvent.prototype=window.Event.prototype),\"complete\"===document.readyState||e.flags.eager)t();else if(\"interactive\"!==document.readyState||window.attachEvent||window.HTMLImports&&!window.HTMLImports.ready){var c=window.HTMLImports&&!window.HTMLImports.ready?\"HTMLImportsLoaded\":\"DOMContentLoaded\";window.addEventListener(c,t)}else t()}(window.CustomElements),\"undefined\"==typeof HTMLTemplateElement&&!function(){function e(e){switch(e){case\"&\":return\"&amp;\";case\"<\":return\"&lt;\";case\">\":return\"&gt;\";case\" \":return\"&nbsp;\"}}function t(t){return t.replace(a,e)}var n=\"template\",r=document.implementation.createHTMLDocument(\"template\"),o=!0;HTMLTemplateElement=function(){},HTMLTemplateElement.prototype=Object.create(HTMLElement.prototype),HTMLTemplateElement.decorate=function(e){e.content||(e.content=r.createDocumentFragment());for(var n;n=e.firstChild;)e.content.appendChild(n);if(o)try{Object.defineProperty(e,\"innerHTML\",{get:function(){for(var e=\"\",n=this.content.firstChild;n;n=n.nextSibling)e+=n.outerHTML||t(n.data);return e},set:function(e){for(r.body.innerHTML=e,HTMLTemplateElement.bootstrap(r);this.content.firstChild;)this.content.removeChild(this.content.firstChild);for(;r.body.firstChild;)this.content.appendChild(r.body.firstChild)},configurable:!0})}catch(i){o=!1}},HTMLTemplateElement.bootstrap=function(e){for(var t,r=e.querySelectorAll(n),o=0,i=r.length;i>o&&(t=r[o]);o++)HTMLTemplateElement.decorate(t)},window.addEventListener(\"DOMContentLoaded\",function(){HTMLTemplateElement.bootstrap(document)});var i=document.createElement;document.createElement=function(){\"use strict\";var e=i.apply(document,arguments);return\"template\"==e.localName&&HTMLTemplateElement.decorate(e),e};var a=/[&\\u00A0<>]/g}(),function(e){\"use strict\";if(!window.performance){var t=Date.now();window.performance={now:function(){return Date.now()-t}}}window.requestAnimationFrame||(window.requestAnimationFrame=function(){var e=window.webkitRequestAnimationFrame||window.mozRequestAnimationFrame;return e?function(t){return e(function(){t(performance.now())})}:function(e){return window.setTimeout(e,1e3/60)}}()),window.cancelAnimationFrame||(window.cancelAnimationFrame=function(){return window.webkitCancelAnimationFrame||window.mozCancelAnimationFrame||function(e){clearTimeout(e)}}())}(window.WebComponents),function(e){var t=document.createElement(\"style\");t.textContent=\"body {transition: opacity ease-in 0.2s; } \\nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \\n\";var n=document.querySelector(\"head\");n.insertBefore(t,n.firstChild)}(window.WebComponents);"
  },
  {
    "__docId__": 233,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/fixtures/source_map.js",
    "memberof": null,
    "longname": "test/fixtures/source_map.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "Object.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _libStore = require('../lib/store');\n\nvar _libStore2 = _interopRequireDefault(_libStore);\n\nvar _lodash = require('lodash');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _utilsFillShape = require('../utils/fill-shape');\n\nvar _utilsFillShape2 = _interopRequireDefault(_utilsFillShape);\n\nvar WindowStore = (function () {\n  function WindowStore() {\n    _classCallCheck(this, WindowStore);\n\n    this.MAIN_WINDOW = 'MAIN_WINDOW';\n    this.SINGLE_TEAM = 'SINGLE_TEAM';\n    this.NOTIFICATIONS = 'NOTIFICATIONS';\n    this.SSB = 'SSB';\n  }\n\n  _createClass(WindowStore, [{\n    key: 'getWindows',\n    value: function getWindows() {\n      return _libStore2['default'].getEntry('windows');\n    }\n  }, {\n    key: 'getWindow',\n    value: function getWindow(id) {\n      return this.getWindows()[id];\n    }\n  }, {\n    key: 'getWindowData',\n    value: function getWindowData(type, params) {\n      return (0, _utilsFillShape2['default'])(_libStore2['default'].getState(), this.getWindowShape(type, params));\n    }\n  }, {\n    key: 'getWindowShape',\n    value: function getWindowShape(type, params) {\n      switch (type) {\n        case this.MAIN_WINDOW:\n          return {\n            app: true,\n            settings: true,\n            teams: true,\n            events: true\n          };\n\n        case this.SINGLE_TEAM:\n          // params=teamId\n          var shape = {\n            app: true,\n            settings: true,\n            teams: {}\n          };\n          shape.teams[params] = true;\n          return shape;\n\n        case this.NOTIFICATIONS:\n          return {\n            notifications: true,\n            teams: true\n          };\n      }\n      return {};\n    }\n  }, {\n    key: 'addWindow',\n    value: function addWindow(windowList, newWindow, type, params) {\n      var update = {};\n      update[newWindow.id] = {\n        window: newWindow,\n        type: type,\n        params: params\n      };\n      return _lodash2['default'].assign({}, windowList, update);\n    }\n  }, {\n    key: 'getShapeForWindow',\n    value: function getShapeForWindow(winId) {\n      var windowData = this.getWindows()[winId];\n      return this.getWindowShape(windowData.type, windowData.params);\n    }\n  }, {\n    key: 'reduce',\n    value: function reduce(windows, action) {\n      if (windows === undefined) windows = {};\n\n      switch (action.type) {\n        case 'ADD_WINDOW':\n          return this.addWindow(windows, action.data.newWindow, action.data.windowType, action.data.params);\n        default:\n          return windows;\n      }\n    }\n  }]);\n\n  return WindowStore;\n})();\n\nexports['default'] = new WindowStore();\nmodule.exports = exports['default'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9wYXVsL2NvZGUvdGlueXNwZWNrL3NsYWNrLXdpbnNzYi9zcmMvc3RvcmVzL3dpbmRvdy1zdG9yZS5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3dCQUFrQixjQUFjOzs7O3NCQUNsQixRQUFROzs7OzhCQUNBLHFCQUFxQjs7OztJQUVyQyxXQUFXO1dBQVgsV0FBVzswQkFBWCxXQUFXOztTQUVmLFdBQVcsR0FBRyxhQUFhO1NBQzNCLFdBQVcsR0FBRyxhQUFhO1NBQzNCLGFBQWEsR0FBRyxlQUFlO1NBQy9CLEdBQUcsR0FBRyxLQUFLOzs7ZUFMUCxXQUFXOztXQU9MLHNCQUFHO0FBQ1gsYUFBTyxzQkFBTSxRQUFRLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDbEM7OztXQUVRLG1CQUFDLEVBQUUsRUFBRTtBQUNaLGFBQU8sSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQzlCOzs7V0FFWSx1QkFBQyxJQUFJLEVBQUUsTUFBTSxFQUFFO0FBQzFCLGFBQU8saUNBQVUsc0JBQU0sUUFBUSxFQUFFLEVBQUUsSUFBSSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUFDLENBQUMsQ0FBQztLQUN2RTs7O1dBRWEsd0JBQUMsSUFBSSxFQUFFLE1BQU0sRUFBRTtBQUMzQixjQUFPLElBQUk7QUFDWCxhQUFLLElBQUksQ0FBQyxXQUFXO0FBQ25CLGlCQUFPO0FBQ0wsZUFBRyxFQUFFLElBQUk7QUFDVCxvQkFBUSxFQUFFLElBQUk7QUFDZCxpQkFBSyxFQUFFLElBQUk7QUFDWCxrQkFBTSxFQUFFLElBQUk7V0FDYixDQUFBOztBQUFBLEFBRUgsYUFBSyxJQUFJLENBQUMsV0FBVzs7QUFDbkIsY0FBSSxLQUFLLEdBQUc7QUFDVixlQUFHLEVBQUUsSUFBSTtBQUNULG9CQUFRLEVBQUUsSUFBSTtBQUNkLGlCQUFLLEVBQUUsRUFBRTtXQUNWLENBQUE7QUFDRCxlQUFLLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQztBQUMzQixpQkFBTyxLQUFLLENBQUM7O0FBQUEsQUFFZixhQUFLLElBQUksQ0FBQyxhQUFhO0FBQ3JCLGlCQUFPO0FBQ0wseUJBQWEsRUFBRSxJQUFJO0FBQ25CLGlCQUFLLEVBQUUsSUFBSTtXQUNaLENBQUE7QUFBQSxPQUNGO0FBQ0QsYUFBTyxFQUFFLENBQUM7S0FDWDs7O1dBRVEsbUJBQUMsVUFBVSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFO0FBQzdDLFVBQUksTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUNoQixZQUFNLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxHQUFHO0FBQ3JCLGNBQU0sRUFBRSxTQUFTO0FBQ2pCLFlBQUksRUFBRSxJQUFJO0FBQ1YsY0FBTSxFQUFFLE1BQU07T0FDZixDQUFDO0FBQ0YsYUFBTyxvQkFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLENBQUMsQ0FBQztLQUN6Qzs7O1dBRWdCLDJCQUFDLEtBQUssRUFBRTtBQUN2QixVQUFJLFVBQVUsR0FBRyxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUMsYUFBTyxJQUFJLENBQUMsY0FBYyxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ2hFOzs7V0FFSyxnQkFBQyxPQUFPLEVBQU8sTUFBTSxFQUFFO1VBQXRCLE9BQU8sZ0JBQVAsT0FBTyxHQUFHLEVBQUU7O0FBQ2pCLGNBQU8sTUFBTSxDQUFDLElBQUk7QUFDaEIsYUFBSyxZQUFZO0FBQ2YsaUJBQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxTQUFTLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxVQUFVLEVBQUUsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUFBLEFBQ3BHO0FBQ0UsaUJBQU8sT0FBTyxDQUFDO0FBQUEsT0FDbEI7S0FDRjs7O1NBckVHLFdBQVc7OztxQkF3RUYsSUFBSSxXQUFXLEVBQUUiLCJmaWxlIjoiL1VzZXJzL3BhdWwvY29kZS90aW55c3BlY2svc2xhY2std2luc3NiL3NyYy9zdG9yZXMvd2luZG93LXN0b3JlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFN0b3JlIGZyb20gJy4uL2xpYi9zdG9yZSc7XG5pbXBvcnQgXyBmcm9tICdsb2Rhc2gnO1xuaW1wb3J0IGZpbGxTaGFwZSBmcm9tICcuLi91dGlscy9maWxsLXNoYXBlJztcblxuY2xhc3MgV2luZG93U3RvcmUge1xuXG4gIE1BSU5fV0lORE9XID0gJ01BSU5fV0lORE9XJztcbiAgU0lOR0xFX1RFQU0gPSAnU0lOR0xFX1RFQU0nO1xuICBOT1RJRklDQVRJT05TID0gJ05PVElGSUNBVElPTlMnO1xuICBTU0IgPSAnU1NCJztcblxuICBnZXRXaW5kb3dzKCkge1xuICAgIHJldHVybiBTdG9yZS5nZXRFbnRyeSgnd2luZG93cycpO1xuICB9XG5cbiAgZ2V0V2luZG93KGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2luZG93cygpW2lkXTtcbiAgfVxuXG4gIGdldFdpbmRvd0RhdGEodHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGZpbGxTaGFwZShTdG9yZS5nZXRTdGF0ZSgpLCB0aGlzLmdldFdpbmRvd1NoYXBlKHR5cGUsIHBhcmFtcykpO1xuICB9XG5cbiAgZ2V0V2luZG93U2hhcGUodHlwZSwgcGFyYW1zKSB7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlIHRoaXMuTUFJTl9XSU5ET1c6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhcHA6IHRydWUsXG4gICAgICAgIHNldHRpbmdzOiB0cnVlLFxuICAgICAgICB0ZWFtczogdHJ1ZSxcbiAgICAgICAgZXZlbnRzOiB0cnVlXG4gICAgICB9XG5cbiAgICBjYXNlIHRoaXMuU0lOR0xFX1RFQU06IC8vIHBhcmFtcz10ZWFtSWRcbiAgICAgIGxldCBzaGFwZSA9IHtcbiAgICAgICAgYXBwOiB0cnVlLFxuICAgICAgICBzZXR0aW5nczogdHJ1ZSxcbiAgICAgICAgdGVhbXM6IHt9XG4gICAgICB9XG4gICAgICBzaGFwZS50ZWFtc1twYXJhbXNdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBzaGFwZTtcblxuICAgIGNhc2UgdGhpcy5OT1RJRklDQVRJT05TOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm90aWZpY2F0aW9uczogdHJ1ZSxcbiAgICAgICAgdGVhbXM6IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgYWRkV2luZG93KHdpbmRvd0xpc3QsIG5ld1dpbmRvdywgdHlwZSwgcGFyYW1zKSB7XG4gICAgbGV0IHVwZGF0ZSA9IHt9O1xuICAgIHVwZGF0ZVtuZXdXaW5kb3cuaWRdID0ge1xuICAgICAgd2luZG93OiBuZXdXaW5kb3csXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgcGFyYW1zOiBwYXJhbXNcbiAgICB9O1xuICAgIHJldHVybiBfLmFzc2lnbih7fSwgd2luZG93TGlzdCwgdXBkYXRlKTtcbiAgfVxuXG4gIGdldFNoYXBlRm9yV2luZG93KHdpbklkKSB7XG4gICAgbGV0IHdpbmRvd0RhdGEgPSB0aGlzLmdldFdpbmRvd3MoKVt3aW5JZF07XG4gICAgcmV0dXJuIHRoaXMuZ2V0V2luZG93U2hhcGUod2luZG93RGF0YS50eXBlLCB3aW5kb3dEYXRhLnBhcmFtcyk7XG4gIH1cblxuICByZWR1Y2Uod2luZG93cyA9IHt9LCBhY3Rpb24pIHtcbiAgICBzd2l0Y2goYWN0aW9uLnR5cGUpIHtcbiAgICAgIGNhc2UgJ0FERF9XSU5ET1cnOlxuICAgICAgICByZXR1cm4gdGhpcy5hZGRXaW5kb3cod2luZG93cywgYWN0aW9uLmRhdGEubmV3V2luZG93LCBhY3Rpb24uZGF0YS53aW5kb3dUeXBlLCBhY3Rpb24uZGF0YS5wYXJhbXMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHdpbmRvd3M7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5ldyBXaW5kb3dTdG9yZSgpO1xuIl19"
  },
  {
    "__docId__": 234,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/fixtures/valid.js",
    "memberof": null,
    "longname": "test/fixtures/valid.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "'use babel';\n\nimport crypto from 'crypto';\nimport path from 'path';\nimport fs from 'fs';\nimport mkdirp from 'mkdirp';\nimport _ from 'lodash';\n\nexport default class CompileCache {\n  constructor() {\n    this.stats = {\n      hits: 0,\n      misses: 0\n    };\n\n    this.cacheDir = null;\n    this.jsCacheDir = null;\n    this.seenFilePaths = {};\n  }\n\n  getCompilerInformation() {\n    throw new Error(\"Implement this in a derived class\");\n  }\n\n  compile(sourceCode, filePath, cachePath) {\n    throw new Error(\"Implement this in a derived class\");\n  }\n\n  getMimeType() {\n    throw new Error(\"Implement this in a derived class\");\n  }\n\n  initializeCompiler() {\n    throw new Error(\"Implement this in a derived class\");\n  }\n\n  shouldCompileFile(sourceCode, fullPath) {\n    this.ensureInitialized();\n    let lowerPath = fullPath.toLowerCase();\n\n    // NB: require() normally does this for us, but in our protocol hook we\n    // need to do this ourselves\n    return _.some(\n      this.extensions,\n      (ext) => lowerPath.lastIndexOf(ext) + ext.length === lowerPath.length);\n  }\n\n  ///\n  /// shasum - Hash with an update() method.\n  /// value - Must be a value that could be returned by JSON.parse().\n  ///\n  updateDigestForJsonValue(shasum, value) {\n    // Implmentation is similar to that of pretty-printing a JSON object, except:\n    // * Strings are not escaped.\n    // * No effort is made to avoid trailing commas.\n    // These shortcuts should not affect the correctness of this function.\n    const type = typeof(value);\n\n    if (type === 'string') {\n      shasum.update('\"', 'utf8');\n      shasum.update(value, 'utf8');\n      shasum.update('\"', 'utf8');\n      return;\n    }\n\n    if (type === 'boolean' || type === 'number') {\n      shasum.update(value.toString(), 'utf8');\n      return;\n    }\n\n    if (value === null) {\n      shasum.update('null', 'utf8');\n      return;\n    }\n\n    if (Array.isArray(value)) {\n      shasum.update('[', 'utf8');\n      for (let i=0; i < value.length; i++) {\n        this.updateDigestForJsonValue(shasum, value[i]);\n        shasum.update(',', 'utf8');\n      }\n      shasum.update(']', 'utf8');\n      return;\n    }\n\n    // value must be an object: be sure to sort the keys.\n    let keys = Object.keys(value);\n    keys.sort();\n\n    shasum.update('{', 'utf8');\n\n    for (let i=0; i < keys.length; i++) {\n      this.updateDigestForJsonValue(shasum, keys[i]);\n      shasum.update(': ', 'utf8');\n      this.updateDigestForJsonValue(shasum, value[keys[i]]);\n      shasum.update(',', 'utf8');\n    }\n\n    shasum.update('}', 'utf8');\n  }\n\n  createDigestForCompilerInformation() {\n    let sha1 = crypto.createHash('sha1');\n    this.updateDigestForJsonValue(sha1, this.getCompilerInformation());\n    return sha1.digest('hex');\n  }\n\n  getCachePath(sourceCode) {\n    let digest = crypto.createHash('sha1').update(sourceCode, 'utf8').digest('hex');\n\n    if (!this.jsCacheDir) {\n      this.jsCacheDir = path.join(this.cacheDir, this.createDigestForCompilerInformation());\n      mkdirp.sync(this.jsCacheDir);\n    }\n\n    return path.join(this.jsCacheDir, `${digest}.js`);\n  }\n\n  getCachedJavaScript(cachePath) {\n    try {\n      let ret = fs.readFileSync(cachePath, 'utf8');\n      this.stats.hits++;\n\n      return ret;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  saveCachedJavaScript(cachePath, js) {\n    fs.writeFileSync(cachePath, js);\n  }\n\n  // Function that obeys the contract of an entry in the require.extensions map.\n  // Returns the transpiled version of the JavaScript code at filePath, which is\n  // either generated on the fly or pulled from cache.\n  loadFile(module, filePath, returnOnly=false, sourceCode=null) {\n    this.ensureInitialized();\n\n    let fullPath = path.resolve(filePath);\n    this.seenFilePaths[path.dirname(filePath)] = true;\n\n    sourceCode = sourceCode || fs.readFileSync(filePath, 'utf8');\n\n    if (!this.shouldCompileFile(sourceCode, fullPath)) {\n      if (returnOnly) return sourceCode;\n      return module._compile(sourceCode, filePath);\n    }\n\n    // NB: We do all of these backflips in order to not load compilers unless\n    // we actually end up using them, since loading them is typically fairly\n    // expensive\n    if (!this.compilerInformation.version) {\n      this.compilerInformation.version = this.initializeCompiler();\n    }\n\n    let cachePath = this.getCachePath(sourceCode);\n    let js = this.getCachedJavaScript(cachePath);\n\n    if (!js) {\n      js = this.compile(sourceCode, filePath, cachePath);\n      this.stats.misses++;\n\n      this.saveCachedJavaScript(cachePath, js);\n    }\n\n    if (returnOnly) return js;\n    return module._compile(js, filePath);\n  }\n\n  register() {\n    this.ensureInitialized();\n\n    for (let i=0; i < this.extensions.length; i++) {\n      Object.defineProperty(require.extensions, `.${this.extensions[i]}`, {\n        enumerable: true,\n        writable: false,\n        value: (module, filePath) => this.loadFile(module, filePath)\n      });\n    }\n  }\n\n  ensureInitialized() {\n    if (this.extensions) return;\n\n    let info = this.getCompilerInformation();\n\n    if (!info.extension && !info.extensions) {\n      throw new Error(\"Compiler must register at least one extension in getCompilerInformation\");\n    }\n\n    this.extensions = (info.extensions ? info.extensions : [info.extension]);\n  }\n\n  setCacheDirectory(newCacheDir) {\n    if (this.cacheDir === newCacheDir) return;\n\n    this.cacheDir = newCacheDir;\n    this.jsCacheDir = null;\n  }\n}\n"
  },
  {
    "__docId__": 235,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/inline-html-compiler.js",
    "memberof": null,
    "longname": "test/inline-html-compiler.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './support.js';\n\nimport fs from 'fs';\nimport path from 'path';\nimport cheerio from 'cheerio';\nimport pify from 'pify';\nimport _ from 'lodash';\n\nconst validInputs = [\n  'inline-valid.html',\n  'inline-valid-2.html'\n];\n\nconst pfs = pify(fs);\nconst InlineHtmlCompiler = global.compilersByMimeType['text/html'];\n\nconst d = require('debug')('test:inline-html-compiler');\n\ndescribe('The inline HTML compiler', function() {\n  beforeEach(function() {\n    let compilers = _.reduce(Object.keys(global.compilersByMimeType), (acc, x) => {\n      let Klass = global.compilersByMimeType[x];\n      acc[x] = new Klass();\n      \n      return acc;\n    }, {});\n    \n    compilers['application/javascript'].compilerOptions = {\n      \"presets\": [\"stage-0\", \"es2015\", \"react\"],\n      \"sourceMaps\": \"inline\"\n    };\n    \n    compilers['text/coffeescript'].compilerOptions = { sourceMap: true };\n    \n    this.fixture = InlineHtmlCompiler.createFromCompilers(compilers);\n  });\n\n  _.each(validInputs, (inputFile) => {\n    it('should compile the valid fixture ' + inputFile, async function() {\n      let input = path.join(__dirname, '..', 'test', 'fixtures', inputFile);\n\n      let cc = {};\n      expect(await this.fixture.shouldCompileFile(input, cc)).to.be.ok;\n\n      let code = await pfs.readFile(input, 'utf8');\n      let df = await this.fixture.determineDependentFiles(input, code, cc);\n\n      expect(df.length).to.equal(0);\n\n      let result = await this.fixture.compile(code, input, cc);\n      expect(result.mimeType).to.equal('text/html');\n\n      let $ = cheerio.load(result.code);\n      let tags = $('script');\n      expect(tags.length > 0).to.be.ok;\n\n      $('script').map((__, el) => {\n        let text = $(el).text();\n        if (!text || text.length < 2) return;\n\n        expect(_.find(text.split('\\n'), (l) => l.match(/sourceMappingURL/))).to.be.ok;\n      });\n    });\n\n    it('should compile the valid fixture ' + inputFile + ' synchronously', function() {\n      let input = path.join(__dirname, '..', 'test', 'fixtures', inputFile);\n\n      let cc = {};\n      expect(this.fixture.shouldCompileFileSync(input, cc)).to.be.ok;\n\n      let code = fs.readFileSync(input, 'utf8');\n      let df = this.fixture.determineDependentFilesSync(input, code, cc);\n\n      expect(df.length).to.equal(0);\n\n      let result = this.fixture.compileSync(code, input, cc);\n      expect(result.mimeType).to.equal('text/html');\n\n      let $ = cheerio.load(result.code);\n      let tags = $('script');\n      expect(tags.length > 0).to.be.ok;\n\n      $('script').map((__, el) => {\n        let text = $(el).text();\n        if (!text || text.length < 2) return;\n\n        d(text);\n        expect(_.find(text.split('\\n'), (l) => l.match(/sourceMappingURL/))).to.be.ok;\n      });\n    });\n  });\n\n  it('should remove protocol-relative URLs because they are dumb', async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'roboto.html');\n\n    let cc = {};\n    expect(await this.fixture.shouldCompileFile(input, cc)).to.be.ok;\n\n    let code = await pfs.readFile(input, 'utf8');\n    let df = await this.fixture.determineDependentFiles(input, code, cc);\n\n    expect(df.length).to.equal(0);\n\n    let result = await this.fixture.compile(code, input, cc);\n\n    expect(result.code.length > 0).to.be.ok;\n    expect(result.mimeType).to.equal('text/html');\n\n    let $ = cheerio.load(result.code);\n    let tags = $('link');\n    expect(tags.length === 1).to.be.ok;\n    expect($(tags[0]).attr('href').match(/^https/i)).to.be.ok;\n  });\n\n  it('should canonicalize x-require paths', async function() {\n    let input = path.join(__dirname, '..', 'test', 'fixtures', 'x-require-valid.html');\n\n    let cc = {};\n    expect(await this.fixture.shouldCompileFile(input, cc)).to.be.ok;\n\n    let code = await pfs.readFile(input, 'utf8');\n    let df = await this.fixture.determineDependentFiles(input, code, cc);\n\n    expect(df.length).to.equal(0);\n\n    let result = await this.fixture.compile(code, input, cc);\n\n    expect(result.code.length > 0).to.be.ok;\n    expect(result.mimeType).to.equal('text/html');\n\n    let $ = cheerio.load(result.code);\n    let tags = $('x-require');\n    expect(tags.length === 1).to.be.ok;\n\n    $('x-require').map((__, el) => {\n      let src = $(el).attr('src');\n      expect(_.find(src.split(/[\\\\\\/]/), (x) => x === '.' || x === '..')).not.to.be.ok;\n    });\n  });\n});\n"
  },
  {
    "__docId__": 236,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe45",
    "testId": 45,
    "memberof": "test/inline-html-compiler.js",
    "testDepth": 0,
    "longname": "test/inline-html-compiler.js~describe45",
    "access": null,
    "description": "The inline HTML compiler",
    "lineNumber": 19
  },
  {
    "__docId__": 237,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it46",
    "testId": 46,
    "memberof": "test/inline-html-compiler.js~describe45",
    "testDepth": 1,
    "longname": "test/inline-html-compiler.js~describe45.it46",
    "access": null,
    "lineNumber": 39
  },
  {
    "__docId__": 238,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it47",
    "testId": 47,
    "memberof": "test/inline-html-compiler.js~describe45",
    "testDepth": 1,
    "longname": "test/inline-html-compiler.js~describe45.it47",
    "access": null,
    "lineNumber": 65
  },
  {
    "__docId__": 239,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it48",
    "testId": 48,
    "memberof": "test/inline-html-compiler.js~describe45",
    "testDepth": 1,
    "longname": "test/inline-html-compiler.js~describe45.it48",
    "access": null,
    "description": "should remove protocol-relative URLs because they are dumb",
    "lineNumber": 93
  },
  {
    "__docId__": 240,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it49",
    "testId": 49,
    "memberof": "test/inline-html-compiler.js~describe45",
    "testDepth": 1,
    "longname": "test/inline-html-compiler.js~describe45.it49",
    "access": null,
    "description": "should canonicalize x-require paths",
    "lineNumber": 115
  },
  {
    "__docId__": 241,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/protocol-hook.js",
    "memberof": null,
    "longname": "test/protocol-hook.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import './support.js';\n\nimport _ from 'lodash';\nimport path from 'path';\nimport fs from 'fs';\n\nimport {rigHtmlDocumentToInitializeElectronCompile} from '../lib/protocol-hook';\n\ndescribe('protocol hook library', function() {\n  describe('The HTML include rigging', function() {\n    it('should rig pages with HEAD tags', function() {\n      let content = fs.readFileSync(path.join(__dirname, '..', 'test', 'fixtures', 'protourlrigging_1.html'), 'utf8');\n      let result = rigHtmlDocumentToInitializeElectronCompile(content);\n      \n      let lines = result.split('\\n');\n      expect(_.any(lines, (x) => x.match(/head.*__magic__file/i))).to.be.ok;\n    });\n    \n    it('should rig pages without tags', function() {\n      let content = fs.readFileSync(path.join(__dirname, '..', 'test', 'fixtures', 'protourlrigging_2.html'), 'utf8');\n      let result = rigHtmlDocumentToInitializeElectronCompile(content);\n      \n      let lines = result.split('\\n');\n      expect(_.any(lines, (x) => x.match(/head.*__magic__file/i))).to.be.ok;\n    });\n  });\n});\n"
  },
  {
    "__docId__": 242,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe50",
    "testId": 50,
    "memberof": "test/protocol-hook.js",
    "testDepth": 0,
    "longname": "test/protocol-hook.js~describe50",
    "access": null,
    "description": "protocol hook library",
    "lineNumber": 9
  },
  {
    "__docId__": 243,
    "kind": "testDescribe",
    "static": true,
    "variation": null,
    "name": "describe51",
    "testId": 51,
    "memberof": "test/protocol-hook.js~describe50",
    "testDepth": 1,
    "longname": "test/protocol-hook.js~describe50.describe51",
    "access": null,
    "description": "The HTML include rigging",
    "lineNumber": 10
  },
  {
    "__docId__": 244,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it52",
    "testId": 52,
    "memberof": "test/protocol-hook.js~describe50.describe51",
    "testDepth": 2,
    "longname": "test/protocol-hook.js~describe50.describe51.it52",
    "access": null,
    "description": "should rig pages with HEAD tags",
    "lineNumber": 11
  },
  {
    "__docId__": 245,
    "kind": "testIt",
    "static": true,
    "variation": null,
    "name": "it53",
    "testId": 53,
    "memberof": "test/protocol-hook.js~describe50.describe51",
    "testDepth": 2,
    "longname": "test/protocol-hook.js~describe50.describe51.it53",
    "access": null,
    "description": "should rig pages without tags",
    "lineNumber": 19
  },
  {
    "__docId__": 246,
    "kind": "testFile",
    "static": true,
    "variation": null,
    "name": "test/support.js",
    "memberof": null,
    "longname": "test/support.js",
    "access": null,
    "description": null,
    "lineNumber": 1,
    "content": "import 'babel-polyfill';\n\nimport _ from 'lodash';\n\nconst allCompilerClasses = require('electron-compilers');\n\nlet chai = require(\"chai\");\nlet chaiAsPromised = require(\"chai-as-promised\");\n\nchai.should();\nchai.use(chaiAsPromised);\n\nglobal.chai = chai;\nglobal.chaiAsPromised = chaiAsPromised;\nglobal.expect = chai.expect;\nglobal.AssertionError = chai.AssertionError;\nglobal.Assertion = chai.Assertion;\nglobal.assert = chai.assert;\n\nrequire('../lib/rig-mime-types').init();\n\nglobal.compilersByMimeType = _.reduce(allCompilerClasses, (acc,x) => {\n  acc = acc || {};\n  \n  for (let type of x.getInputMimeTypes()) { acc[type] = x; }\n  return acc;\n}, {});\n"
  }
]